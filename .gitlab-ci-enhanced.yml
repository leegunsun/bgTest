---
# Enhanced True Blue-Green Deployment CI/CD Pipeline v2.0
# Complete load balancing with gradual migration and dual update cycle

default:
  tags:
    - mac-mini

stages:
  - build-dev
  - test-dev
  - detect-env-dev
  - deploy-inactive-dev
  - dual-validation-dev
  - gradual-migration-dev
  - post-migration-validation-dev
  - finalize-deployment-dev
  - monitoring-setup-dev
  - cleanup-dev

# Enhanced variables with load balancing support
variables:
  GIT_DEPTH: "0"
  NODE_OPTIONS: "--max_old_space_size=2048"
  DOCKER_DRIVER: overlay2
  COMPOSE_FILE: "docker-compose.yml"
  # Enhanced versioning with deployment tracking
  BLUE_VERSION: "${CI_COMMIT_TAG:-${CI_COMMIT_SHORT_SHA}}"
  GREEN_VERSION: "${CI_COMMIT_TAG:-${CI_COMMIT_SHORT_SHA}}"
  DEPLOYMENT_VERSION: "${CI_COMMIT_TAG:-${CI_COMMIT_SHORT_SHA}}"
  DEPLOYMENT_ID: "${CI_PIPELINE_ID}-${CI_COMMIT_SHORT_SHA}"
  # Load balancing configuration
  MIGRATION_TYPE: "gradual"
  HEALTH_CHECK_RETRIES: "5"
  ROLLBACK_TIMEOUT: "300"

# Reusable rules
.rules_dev_and_main: &rules_dev_main
  rules:
    - if: '$CI_COMMIT_BRANCH == "dev"'
    - if: '$CI_COMMIT_BRANCH == "main"'
    - when: never

# Enhanced SSH setup with monitoring tools
.enhanced_ssh_setup: &enhanced_ssh_setup
  before_script:
    - apk add --no-cache bash openssh-client curl jq docker docker-compose bc
    - eval $(ssh-agent -s)
    - echo "🔍 Validating Enhanced CI/CD Configuration..."
    - |
      if [ -z "$AWS_PEM_DEV" ] || [ -z "$DEPLOY_SERVER_DEV" ]; then
        echo "❌ ERROR: Required CI/CD variables not configured"
        echo "Required: AWS_PEM_DEV (File), DEPLOY_SERVER_DEV (Variable)"
        exit 1
      fi
    - chmod 600 "$AWS_PEM_DEV"
    - ssh-add "$AWS_PEM_DEV"
    - mkdir -p ~/.ssh
    - echo -e "Host *\n\tStrictHostKeyChecking no\n" > ~/.ssh/config
    - echo "✅ Enhanced SSH setup completed"

# 1. Enhanced Build Stage
build-enhanced:
  stage: build-dev
  image: node:18-alpine
  <<: *rules_dev_main
  script:
    - echo "🏗️  Building Enhanced Blue-Green architecture with version ${DEPLOYMENT_VERSION}..."
    - cp "$DEV_ENV_FILE" ./.env || echo "No env file configured"
    - echo "VERSION=${DEPLOYMENT_VERSION}" >> ./.env
    - echo "DEPLOYMENT_ID=${DEPLOYMENT_ID}" >> ./.env
    - echo "MIGRATION_TYPE=${MIGRATION_TYPE}" >> ./.env
    - echo "📦 Enhanced artifacts with load balancing support..."
    - echo "🔧 Enhanced configuration:"
    - echo "   BLUE_VERSION=${BLUE_VERSION}"
    - echo "   GREEN_VERSION=${GREEN_VERSION}"
    - echo "   DEPLOYMENT_VERSION=${DEPLOYMENT_VERSION}"
    - echo "   DEPLOYMENT_ID=${DEPLOYMENT_ID}"
    - echo "   MIGRATION_TYPE=${MIGRATION_TYPE}"
  artifacts:
    expire_in: 3 days
    paths:
      - ./app-service/
      - ./api-service/
      - ./monitoring/
      - ./scripts/
      - ./app-server/
      - ./nginx.conf
      - ./nginx-enhanced.conf
      - ./conf.d/
      - ./admin.html
      - ./docker-compose.yml
      - ./.env

# 2. Enhanced Testing Stage  
test-enhanced:
  stage: test-dev
  image: node:18-alpine
  <<: *rules_dev_main
  needs: ["build-enhanced"]
  script:
    - echo "🧪 Testing Enhanced Load Balancing Architecture..."
    - node -c app-server/app.js
    - node -c api-service/app.js
    - node -c api-service/enhanced-api.js
    - echo "✅ All service syntax checks passed - Enhanced architecture validated"

# 3. Enhanced Environment Detection
detect-active-environment-enhanced:
  stage: detect-env-dev
  image: alpine:latest
  <<: [*enhanced_ssh_setup, *rules_dev_main]
  needs: ["build-enhanced", "test-enhanced"]
  script:
    - echo "🔍 Enhanced Environment Detection with Load Balancing Support..."
    - |
      ssh "ubuntu@$DEPLOY_SERVER_DEV" '
        cd ~/bgTest/v5ToWindow
        echo "📊 Enhanced Environment Detection:"
        
        if docker ps --filter "name=nginx-proxy" --format "table {{.Names}}" | grep -q nginx-proxy; then
          echo "✅ Enhanced Blue-Green system is running"
          
          # Enhanced detection with API fallback and load balancer status
          echo "🔍 Multi-layer environment detection..."
          
          # Priority 1: Enhanced API detection
          ENHANCED_API_RESPONSE=$(docker run --rm --network bluegreen-network curlimages/curl:latest \
            curl -s --max-time 10 "http://api-server:9000/status" 2>/dev/null || echo "")
          API_ACTIVE=$(echo "$ENHANCED_API_RESPONSE" | jq -r ".active" 2>/dev/null || echo "")
          MIGRATION_STATUS=$(echo "$ENHANCED_API_RESPONSE" | jq -r ".migration.status" 2>/dev/null || echo "stable")
          
          # Priority 2: File-based detection
          FILE_ACTIVE=$(docker exec nginx-proxy cat /etc/nginx/conf.d/active.env | grep -o "blue\|green" 2>/dev/null || echo "")
          
          echo "📊 Detection Results:"
          echo "   API Active: $API_ACTIVE"
          echo "   File Active: $FILE_ACTIVE"
          echo "   Migration Status: $MIGRATION_STATUS"
          
          # Enhanced logic for environment selection
          if [ -n "$API_ACTIVE" ] && [ "$API_ACTIVE" != "null" ]; then
            CURRENT_ACTIVE="$API_ACTIVE"
            echo "🎯 Using API-detected environment: $CURRENT_ACTIVE"
          elif [ -n "$FILE_ACTIVE" ]; then
            CURRENT_ACTIVE="$FILE_ACTIVE"
            echo "📄 Using file-detected environment: $CURRENT_ACTIVE"
          else
            CURRENT_ACTIVE="blue"
            echo "⚠️  No detection, defaulting to: $CURRENT_ACTIVE"
          fi
          
          # Check if migration is already in progress
          if [ "$MIGRATION_STATUS" = "migrating" ]; then
            echo "⚠️  Migration in progress - may need cleanup before new deployment"
          fi
          
          # Enhanced deployment target logic
          if [ "$CURRENT_ACTIVE" = "blue" ]; then
            DEPLOY_TARGET="green"
            echo "🔵→🟢 Enhanced: Current blue, Deploying to green"
          else
            DEPLOY_TARGET="blue"
            echo "🟢→🔵 Enhanced: Current green, Deploying to blue"
          fi
        else
          echo "⚠️  Enhanced system not running, initializing green deployment"
          CURRENT_ACTIVE="blue"
          DEPLOY_TARGET="green"
          MIGRATION_STATUS="stable"
        fi
        
        echo "Enhanced Results:"
        echo "Current active: $CURRENT_ACTIVE"
        echo "Deploy target: $DEPLOY_TARGET"
        echo "Migration status: $MIGRATION_STATUS"
        
        # Enhanced state persistence
        echo "$CURRENT_ACTIVE" > ~/current_active.env
        echo "$DEPLOY_TARGET" > ~/deploy_target.env
        echo "$MIGRATION_STATUS" > ~/migration_status.env
      '

# 4. Enhanced Deployment to Inactive Environment
deploy-to-inactive-enhanced:
  stage: deploy-inactive-dev
  image: alpine:latest
  <<: [*enhanced_ssh_setup, *rules_dev_main]
  needs: ["detect-active-environment-enhanced"]
  environment:
    name: inactive-env-enhanced
    url: "http://$DEPLOY_SERVER_DEV"
  script:
    - echo "🚀 ENHANCED DEPLOYMENT - Load balancing ready deployment"
    - echo "📁 Transferring enhanced service architecture..."
    - ssh "ubuntu@$DEPLOY_SERVER_DEV" "mkdir -p ~/bgTest/v5ToWindow"
    - scp -r ./ "ubuntu@$DEPLOY_SERVER_DEV:~/bgTest/v5ToWindow/"
    - echo "🐳 Enhanced deployment with load balancing support..."
    - |
      ssh "ubuntu@$DEPLOY_SERVER_DEV" '
        cd ~/bgTest/v5ToWindow
        
        DEPLOY_TARGET=$(cat ~/deploy_target.env 2>/dev/null || echo "green")
        DEPLOY_VERSION="'${DEPLOYMENT_VERSION}'"
        DEPLOY_ID="'${DEPLOYMENT_ID}'"
        echo "🎯 Enhanced deployment: $DEPLOY_VERSION to $DEPLOY_TARGET (ID: $DEPLOY_ID)"
        
        # Enhanced version management
        if [ "$DEPLOY_TARGET" = "blue" ]; then
          export BLUE_VERSION="$DEPLOY_VERSION"
          echo "BLUE_VERSION=$DEPLOY_VERSION" >> .env
          echo "🔵 Enhanced: BLUE_VERSION=$DEPLOY_VERSION"
        else
          export GREEN_VERSION="$DEPLOY_VERSION"
          echo "GREEN_VERSION=$DEPLOY_VERSION" >> .env
          echo "🟢 Enhanced: GREEN_VERSION=$DEPLOY_VERSION"
        fi
        
        # Enhanced deployment state management
        mkdir -p deployment_state
        echo "{\"deployment_id\":\"$DEPLOY_ID\",\"version\":\"$DEPLOY_VERSION\",\"target\":\"$DEPLOY_TARGET\",\"timestamp\":\"$(date -u +"%Y-%m-%dT%H:%M:%SZ")\",\"type\":\"enhanced\"}" > deployment_state/current_deployment.json
        
        # Docker setup (enhanced)
        if ! command -v docker &> /dev/null; then
          echo "📦 Installing Docker for enhanced deployment..."
          curl -fsSL https://get.docker.com -o get-docker.sh
          sudo sh get-docker.sh
          sudo usermod -aG docker ubuntu
          sudo systemctl start docker
          sudo systemctl enable docker
        fi
        
        sudo usermod -aG docker ubuntu
        sudo systemctl restart docker
        sudo chmod 666 /var/run/docker.sock || true
        
        # Enhanced tools installation
        sudo apt-get update -qq >/dev/null 2>&1 || true
        sudo apt-get install -y netcat-openbsd net-tools jq bc >/dev/null 2>&1 || true
        
        # Docker Compose (enhanced)
        if ! command -v docker-compose &> /dev/null; then
          echo "📦 Installing Docker Compose for enhanced deployment..."
          sudo curl -L "https://github.com/docker/compose/releases/download/v2.24.0/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
          sudo chmod +x /usr/local/bin/docker-compose
          sudo ln -sf /usr/local/bin/docker-compose /usr/bin/docker-compose
        fi
        
        # Enhanced system initialization or deployment
        if docker ps --filter "name=nginx-proxy" --format "table {{.Names}}" | grep -q nginx-proxy; then
          echo "✅ Enhanced system running - deploying to inactive $DEPLOY_TARGET"
          
          # Enhanced API server rebuild (with load balancing support)
          echo "🔧 Rebuilding enhanced API server with load balancing..."
          docker-compose -f docker-compose.yml build api-server || sudo docker-compose -f docker-compose.yml build api-server
          docker-compose -f docker-compose.yml up -d --no-deps --force-recreate api-server || sudo docker-compose -f docker-compose.yml up -d --no-deps --force-recreate api-server
          
          # Enhanced target environment deployment
          echo "🎯 Enhanced deployment to $DEPLOY_TARGET environment..."
          docker-compose -f docker-compose.yml build ${DEPLOY_TARGET}-app || sudo docker-compose -f docker-compose.yml build ${DEPLOY_TARGET}-app
          docker-compose -f docker-compose.yml up -d --no-deps --force-recreate ${DEPLOY_TARGET}-app || sudo docker-compose -f docker-compose.yml up -d --no-deps --force-recreate ${DEPLOY_TARGET}-app
          
          echo "⏳ Enhanced startup validation..."
          sleep 60  # Extended wait for enhanced features
          
        else
          echo "🏗️  Enhanced system initialization - full deployment"
          
          # Enhanced active.env initialization
          if [ ! -f "conf.d/active.env" ]; then
            echo "🔧 Enhanced active.env initialization..."
            echo "set \$active \"green\";" > conf.d/active.env
          fi
          
          # Enhanced system startup
          docker-compose -f docker-compose.yml down --timeout 10 || sudo docker-compose -f docker-compose.yml down --timeout 10 || true
          docker-compose -f docker-compose.yml build || sudo docker-compose -f docker-compose.yml build
          docker-compose -f docker-compose.yml up -d || sudo docker-compose -f docker-compose.yml up -d
          
          echo "⏳ Enhanced system startup (full initialization)..."
          sleep 120
        fi
        
        # Enhanced health validation with load balancing checks
        echo "🏥 Enhanced health validation with load balancing support..."
        TARGET_PORT=$(if [ "$DEPLOY_TARGET" = "blue" ]; then echo "3001"; else echo "3002"; fi)
        APP_CONTAINER="${DEPLOY_TARGET}-app"
        
        # Enhanced health check with multiple validation layers
        for attempt in $(seq 1 50); do
          echo "🔍 Enhanced health check $attempt/50 for $DEPLOY_TARGET"
          
          # Layer 1: Docker health status
          DOCKER_HEALTH=$(docker inspect --format="{{.State.Health.Status}}" "$APP_CONTAINER" 2>/dev/null || echo "no-health")
          echo "🐳 Docker health: $DOCKER_HEALTH"
          
          # Layer 2: HTTP health check
          HTTP_HEALTH="false"
          if docker exec "$APP_CONTAINER" sh -c "curl -sS -f --max-time 3 http://localhost:$TARGET_PORT/health >/dev/null" 2>/dev/null; then
            HTTP_HEALTH="true"
            echo "🌐 HTTP health: passed"
          else
            echo "🌐 HTTP health: failed"
          fi
          
          # Layer 3: Enhanced API health check
          API_HEALTH="false"
          if docker run --rm --network bluegreen-network curlimages/curl:latest \
               -sS -f --max-time 5 "http://${APP_CONTAINER}:${TARGET_PORT}/health" >/dev/null 2>/dev/null; then
            API_HEALTH="true"
            echo "🔌 API health: passed"
          else
            echo "🔌 API health: failed"
          fi
          
          # Enhanced validation logic
          if [ "$DOCKER_HEALTH" = "healthy" ] && [ "$HTTP_HEALTH" = "true" ] && [ "$API_HEALTH" = "true" ]; then
            echo "✅ Enhanced health validation passed!"
            
            # Version verification
            DEPLOYED_VERSION=$(docker exec "$APP_CONTAINER" sh -c "curl -s --max-time 3 http://localhost:$TARGET_PORT/version 2>/dev/null | jq -r .version 2>/dev/null" || echo "unknown")
            echo "📋 Enhanced deployment verified: $DEPLOYED_VERSION"
            break
          fi
          
          # Enhanced debugging at key intervals
          if [ $attempt -eq 10 ] || [ $attempt -eq 25 ] || [ $attempt -eq 40 ]; then
            echo "🔍 [Enhanced DEBUG] Attempt $attempt status:"
            docker ps -a --format "table {{.Names}}\\t{{.Status}}\\t{{.Ports}}" | grep -E "(nginx|${DEPLOY_TARGET}|api)" || true
            docker logs --tail 10 "$APP_CONTAINER" 2>&1 | head -15 || echo "No $APP_CONTAINER logs"
          fi
          
          if [ $attempt -eq 50 ]; then
            echo "❌ Enhanced health validation failed after $attempt attempts"
            exit 1
          fi
          
          # Progressive backoff
          sleep_time=$(( 5 + attempt / 10 ))
          sleep "$sleep_time"
        done
        
        echo "🎉 Enhanced deployment to inactive environment completed!"
      '

# 5. Dual Environment Validation (NEW STAGE)
dual-environment-validation:
  stage: dual-validation-dev
  image: alpine:latest
  <<: [*enhanced_ssh_setup, *rules_dev_main]
  needs: ["deploy-to-inactive-enhanced"]
  script:
    - echo "🔍 Enhanced Dual Environment Validation"
    - |
      ssh "ubuntu@$DEPLOY_SERVER_DEV" '
        cd ~/bgTest/v5ToWindow
        echo "🏥 Validating both Blue and Green environments for load balancing..."
        
        # Enhanced dual validation via API
        VALIDATION_RESULT=$(docker run --rm --network bluegreen-network curlimages/curl:latest \
          curl -s --max-time 15 "http://api-server:9000/validate" 2>/dev/null || echo "{\"success\":false}")
        
        echo "📊 Validation result: $VALIDATION_RESULT"
        
        VALIDATION_SUCCESS=$(echo "$VALIDATION_RESULT" | jq -r ".success" 2>/dev/null || echo "false")
        
        if [ "$VALIDATION_SUCCESS" = "true" ]; then
          echo "✅ Enhanced dual environment validation passed"
          echo "🟢 Both environments ready for load balancing"
        else
          echo "❌ Enhanced dual environment validation failed"
          VALIDATION_ERROR=$(echo "$VALIDATION_RESULT" | jq -r ".error" 2>/dev/null || echo "Unknown validation error")
          echo "Error: $VALIDATION_ERROR"
          exit 1
        fi
      '

# 6. Gradual Migration (NEW ENHANCED STAGE)
gradual-traffic-migration:
  stage: gradual-migration-dev
  image: alpine:latest
  <<: [*enhanced_ssh_setup, *rules_dev_main]
  needs: ["dual-environment-validation"]
  when: manual
  allow_failure: false
  environment:
    name: production-enhanced
    url: "http://$DEPLOY_SERVER_DEV"
  script:
    - echo "🔄 Enhanced Gradual Traffic Migration"
    - |
      ssh "ubuntu@$DEPLOY_SERVER_DEV" '
        cd ~/bgTest/v5ToWindow
        DEPLOY_TARGET=$(cat ~/deploy_target.env 2>/dev/null || echo "green")
        
        echo "🚦 Starting gradual migration to $DEPLOY_TARGET (25% → 50% → 75% → 100%)..."
        
        # Enhanced gradual migration via enhanced API
        MIGRATION_START=$(date +%s)
        MIGRATION_RESULT=$(docker run --rm --network bluegreen-network curlimages/curl:latest \
          curl -s -X POST --max-time 600 "http://api-server:9000/switch/$DEPLOY_TARGET" 2>/dev/null || echo "{\"success\":false}")
        MIGRATION_END=$(date +%s)
        MIGRATION_DURATION=$((MIGRATION_END - MIGRATION_START))
        
        echo "📊 Migration result: $MIGRATION_RESULT"
        echo "⏱️  Migration duration: ${MIGRATION_DURATION}s"
        
        MIGRATION_SUCCESS=$(echo "$MIGRATION_RESULT" | jq -r ".success" 2>/dev/null || echo "false")
        
        if [ "$MIGRATION_SUCCESS" = "true" ]; then
          echo "✅ Enhanced gradual migration completed successfully"
          
          # Show migration steps
          echo "📈 Migration steps completed:"
          echo "$MIGRATION_RESULT" | jq -r ".steps[]? | \"  \(.percentage)% - \(.timestamp) - \(.status)\"" 2>/dev/null || echo "  Steps data not available"
          
          echo "🎯 Traffic successfully migrated to $DEPLOY_TARGET environment"
        else
          echo "❌ Enhanced gradual migration failed"
          MIGRATION_ERROR=$(echo "$MIGRATION_RESULT" | jq -r ".error" 2>/dev/null || echo "Unknown migration error")
          echo "Error: $MIGRATION_ERROR"
          exit 1
        fi
      '

# 7. Post-Migration Validation (ENHANCED)
post-migration-validation:
  stage: post-migration-validation-dev
  image: alpine:latest
  <<: [*enhanced_ssh_setup, *rules_dev_main]
  needs: ["gradual-traffic-migration"]
  script:
    - echo "🔍 Enhanced Post-Migration Validation"
    - |
      ssh "ubuntu@$DEPLOY_SERVER_DEV" '
        cd ~/bgTest/v5ToWindow
        
        echo "📊 Enhanced post-migration health and performance validation..."
        
        # Extended validation with performance metrics
        failed_checks=0
        total_checks=100
        response_times=()
        
        echo "🧪 Running $total_checks enhanced validation checks..."
        
        for i in $(seq 1 $total_checks); do
          start_time=$(date +%s%3N)
          
          if curl -f --max-time 5 "http://localhost:80/status" >/dev/null 2>&1; then
            end_time=$(date +%s%3N)
            response_time=$((end_time - start_time))
            response_times+=($response_time)
            
            # Log slow responses
            if [ $response_time -gt 1000 ]; then
              echo "⚠️  Slow response: ${response_time}ms (check $i)"
            fi
          else
            failed_checks=$((failed_checks + 1))
            echo "❌ Failed check $i"
          fi
          
          # Progressive logging
          if [ $((i % 25)) -eq 0 ]; then
            echo "📊 Progress: $i/$total_checks (failures: $failed_checks)"
          fi
          
          sleep 0.5
        done
        
        # Calculate performance metrics
        if [ ${#response_times[@]} -gt 0 ]; then
          avg_response=$(( $(IFS=+; echo "$((${response_times[*]}))") / ${#response_times[@]} ))
          echo "📈 Average response time: ${avg_response}ms"
        fi
        
        availability=$(echo "scale=2; (1 - $failed_checks/$total_checks) * 100" | bc -l || echo "0")
        
        echo "📊 Enhanced validation results:"
        echo "   - Total checks: $total_checks"
        echo "   - Failed checks: $failed_checks" 
        echo "   - Availability: ${availability}%"
        echo "   - Performance checks: ${#response_times[@]}"
        
        # Enhanced validation criteria
        if [ "$failed_checks" -eq 0 ]; then
          echo "🎉 ENHANCED VALIDATION PERFECT!"
          echo "✅ 100% availability achieved"
        elif [ "$failed_checks" -le 2 ]; then
          echo "⚠️  Enhanced validation passed with minor issues"
          echo "   Availability: ${availability}% (acceptable)"
        else
          echo "❌ Enhanced validation failed"
          echo "   Too many failures detected"
          exit 1
        fi
      '

# 8. Deployment Finalization (NEW STAGE)
finalize-enhanced-deployment:
  stage: finalize-deployment-dev
  image: alpine:latest
  <<: [*enhanced_ssh_setup, *rules_dev_main]
  needs: ["post-migration-validation"]
  script:
    - echo "✨ Enhanced Deployment Finalization"
    - |
      ssh "ubuntu@$DEPLOY_SERVER_DEV" '
        cd ~/bgTest/v5ToWindow
        
        DEPLOY_TARGET=$(cat ~/deploy_target.env 2>/dev/null || echo "green")
        DEPLOY_VERSION="'${DEPLOYMENT_VERSION}'"
        DEPLOY_ID="'${DEPLOYMENT_ID}'"
        
        echo "🎯 Finalizing enhanced deployment:"
        echo "   Environment: $DEPLOY_TARGET"
        echo "   Version: $DEPLOY_VERSION" 
        echo "   Deployment ID: $DEPLOY_ID"
        
        # Enhanced deployment finalization
        mkdir -p deployment_state
        
        # Create comprehensive deployment record
        cat > deployment_state/final_deployment.json << EOF
{
  "deployment_id": "$DEPLOY_ID",
  "version": "$DEPLOY_VERSION",
  "environment": "$DEPLOY_TARGET", 
  "timestamp": "$(date -u +"%Y-%m-%dT%H:%M:%SZ")",
  "type": "enhanced_gradual_migration",
  "pipeline_id": "'${CI_PIPELINE_ID}'",
  "commit_sha": "'${CI_COMMIT_SHA}'",
  "branch": "'${CI_COMMIT_BRANCH}'",
  "migration_type": "gradual",
  "validation_passed": true,
  "finalized": true
}
EOF
        
        # Update deployment history
        if [ -f "deployment_state/deployment_history.json" ]; then
          UPDATED_HISTORY=$(jq --argjson new "$(cat deployment_state/final_deployment.json)" ". + [\$new]" deployment_state/deployment_history.json)
          echo "$UPDATED_HISTORY" > deployment_state/deployment_history.json
        else
          echo "[$(cat deployment_state/final_deployment.json)]" > deployment_state/deployment_history.json
        fi
        
        echo "✅ Enhanced deployment finalization completed"
        echo "📋 Deployment record created and logged"
      '

# 9. Enhanced Monitoring Setup (NEW STAGE) 
setup-enhanced-monitoring:
  stage: monitoring-setup-dev
  image: alpine:latest
  <<: [*enhanced_ssh_setup, *rules_dev_main]
  needs: ["finalize-enhanced-deployment"]
  allow_failure: true
  script:
    - echo "📊 Setting up Enhanced Monitoring"
    - |
      ssh "ubuntu@$DEPLOY_SERVER_DEV" '
        cd ~/bgTest/v5ToWindow
        
        echo "🔧 Enhanced monitoring configuration..."
        
        # Create monitoring configuration
        mkdir -p monitoring/config
        
        # Enhanced monitoring script
        cat > monitoring/enhanced-monitor.sh << "EOF"
#!/bin/bash
# Enhanced monitoring script for Blue-Green deployment

LOGFILE="/var/log/bluegreen-monitor.log"
INTERVAL=30

log_metric() {
    echo "[$(date)] $1" >> "$LOGFILE"
}

while true; do
    # System health
    ACTIVE=$(curl -s http://localhost:9000/status | jq -r ".active" 2>/dev/null || echo "unknown")
    MIGRATION_STATUS=$(curl -s http://localhost:9000/migration | jq -r ".status" 2>/dev/null || echo "unknown")
    
    # Performance metrics
    NGINX_CONNECTIONS=$(docker exec nginx-proxy sh -c "nginx -s reload 2>/dev/null; echo 'OK'" 2>/dev/null || echo "ERROR")
    
    log_metric "HEALTH active=$ACTIVE migration=$MIGRATION_STATUS nginx=$NGINX_CONNECTIONS"
    
    sleep $INTERVAL
done
EOF
        
        chmod +x monitoring/enhanced-monitor.sh
        
        # Start background monitoring (optional)
        # nohup ./monitoring/enhanced-monitor.sh &
        
        echo "✅ Enhanced monitoring setup completed"
        echo "📊 Monitoring script: monitoring/enhanced-monitor.sh"
      '

# 10. Enhanced Cleanup (UPDATED)
cleanup-enhanced-deployment:
  stage: cleanup-dev
  image: alpine:latest
  <<: [*enhanced_ssh_setup, *rules_dev_main]
  needs: ["setup-enhanced-monitoring"]
  when: manual
  allow_failure: true
  script:
    - echo "🧹 Enhanced Deployment Cleanup"
    - |
      ssh "ubuntu@$DEPLOY_SERVER_DEV" '
        cd ~/bgTest/v5ToWindow
        CURRENT_ACTIVE=$(cat ~/current_active.env 2>/dev/null || echo "unknown")
        DEPLOY_TARGET=$(cat ~/deploy_target.env 2>/dev/null || echo "unknown")
        
        echo "🗑️  Enhanced cleanup options:"
        echo "   Previous active: $CURRENT_ACTIVE"
        echo "   Current active: $DEPLOY_TARGET"
        echo "   Both environments remain available for instant rollback"
        echo ""
        echo "✅ Enhanced cleanup completed - system ready for next deployment"
      '

# 11. Emergency Enhanced Rollback (UPDATED)
emergency-enhanced-rollback:
  stage: cleanup-dev
  image: alpine:latest
  <<: [*enhanced_ssh_setup, *rules_dev_main]
  when: manual
  allow_failure: true
  environment:
    name: production-enhanced
    url: "http://$DEPLOY_SERVER_DEV"
  script:
    - echo "🚨 EMERGENCY ENHANCED ROLLBACK"
    - |
      ssh "ubuntu@$DEPLOY_SERVER_DEV" '
        cd ~/bgTest/v5ToWindow
        
        echo "🔄 Emergency rollback using enhanced API..."
        
        ROLLBACK_START=$(date +%s)
        ROLLBACK_RESULT=$(docker run --rm --network bluegreen-network curlimages/curl:latest \
          curl -s -X POST --max-time 120 "http://api-server:9000/rollback" 2>/dev/null || echo "{\"success\":false}")
        ROLLBACK_END=$(date +%s)
        ROLLBACK_DURATION=$((ROLLBACK_END - ROLLBACK_START))
        
        echo "📊 Rollback result: $ROLLBACK_RESULT"
        echo "⏱️  Rollback duration: ${ROLLBACK_DURATION}s"
        
        ROLLBACK_SUCCESS=$(echo "$ROLLBACK_RESULT" | jq -r ".success" 2>/dev/null || echo "false")
        
        if [ "$ROLLBACK_SUCCESS" = "true" ]; then
          ROLLED_BACK_TO=$(echo "$ROLLBACK_RESULT" | jq -r ".rolledBackTo" 2>/dev/null || echo "unknown")
          echo "✅ Enhanced emergency rollback successful"
          echo "🎯 Rolled back to: $ROLLED_BACK_TO environment"
          
          # Verification
          sleep 5
          if curl -f "http://localhost:80/status" >/dev/null 2>&1; then
            echo "✅ Enhanced rollback verification successful"
          else
            echo "⚠️  Rollback completed but verification had issues"
          fi
        else
          echo "❌ Enhanced emergency rollback failed"
          ROLLBACK_ERROR=$(echo "$ROLLBACK_RESULT" | jq -r ".error" 2>/dev/null || echo "Unknown rollback error")
          echo "Error: $ROLLBACK_ERROR"
          exit 1
        fi
      '