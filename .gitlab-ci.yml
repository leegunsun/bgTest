---
# True Blue-Green Deployment CI/CD Pipeline
# Implements zero-downtime deployment with separated container architecture

default:
  tags:
#        - mac-mini
#    - home-runner
    - notebook

stages:
  - build-dev
  - test-dev
  - pre-deployment-validation
  - detect-env-dev
  - deploy-inactive-dev
  - health-check-dev
  - zero-downtime-test-dev
  - switch-traffic-dev
  - verify-deployment-dev
  - cleanup-dev

# Common variables
variables:
  GIT_DEPTH: "0"
#  CI_DEBUG_TRACE: "true"  # ìƒì„¸ ë””ë²„ê·¸ ë¡œê·¸ í™œì„±í™”
  NODE_OPTIONS: "--max_old_space_size=2048"
  DOCKER_DRIVER: overlay2
  COMPOSE_FILE: "docker-compose.yml"
  # Dynamic versioning support
  BLUE_VERSION: "${CI_COMMIT_TAG:-${CI_COMMIT_SHORT_SHA}}"
  GREEN_VERSION: "${CI_COMMIT_TAG:-${CI_COMMIT_SHORT_SHA}}"
  DEPLOYMENT_VERSION: "${CI_COMMIT_TAG:-${CI_COMMIT_SHORT_SHA}}"

# Reusable rules
.rules_dev_and_main: &rules_dev_main
  rules:
    - if: '$CI_COMMIT_BRANCH == "dev"'
    - if: '$CI_COMMIT_BRANCH == "main"'
    - when: never

# Reusable SSH setup
.ssh_setup: &ssh_setup
  before_script:
    - apk add --no-cache bash openssh-client curl jq docker docker-compose
    - eval $(ssh-agent -s)
    - echo "ğŸ” Validating CI/CD Variables..."
    - |
      if [ -z "$AWS_PEM_DEV" ] || [ -z "$DEPLOY_SERVER_DEV" ]; then
        echo "âŒ ERROR: Required CI/CD variables not configured"
        echo "Required: AWS_PEM_DEV (File), DEPLOY_SERVER_DEV (Variable)"
        exit 1
      fi
    - chmod 600 "$AWS_PEM_DEV"
    - ssh-add "$AWS_PEM_DEV"
    - mkdir -p ~/.ssh
    - echo -e "Host *\n\tStrictHostKeyChecking no\n" > ~/.ssh/config
    - echo "âœ… SSH setup completed"

# 1. Build Stage
build-dev:
  stage: build-dev
  image: node:18-alpine
  <<: *rules_dev_main
  script:
    - echo "ğŸ—ï¸  Building Blue-Green unified architecture with version ${DEPLOYMENT_VERSION}..."
    - cp "$DEV_ENV_FILE" ./.env || echo "No env file configured"
    - echo "VERSION=${DEPLOYMENT_VERSION}" >> ./.env
    - echo "ğŸ“¦ Preparing artifacts for unified container deployment..."
    - echo "ğŸ”§ Version configuration:"
    - echo "   BLUE_VERSION=${BLUE_VERSION}"
    - echo "   GREEN_VERSION=${GREEN_VERSION}"
    - echo "   DEPLOYMENT_VERSION=${DEPLOYMENT_VERSION}"
    - ls -la app-service/ api-service/ monitoring/ app-server/ || echo "Service directories ready"
  artifacts:
    expire_in: 3 days
    paths:
      - ./app-service/
      - ./api-service/
      - ./monitoring/
      - ./scripts/
      - ./app-server/
      - ./nginx.conf
      - ./conf.d/
      - ./admin.html
      - ./docker-compose.yml
      - ./.env

# 2. Test Stage
test-dev:
  stage: test-dev
  image: node:18-alpine
  <<: *rules_dev_main
  needs: ["build-dev"]
  script:
    - echo "ğŸ§ª Testing unified services architecture (True Blue-Green Pattern)..."
    - node -c app-server/app.js
    - node -c api-server/app.js
    - echo "âœ… All service syntax checks passed - Single codebase architecture"

# 2.5. Pre-Deployment Validation Stage
pre-deployment-validation:
  stage: pre-deployment-validation
  image: alpine:latest
  <<: [*ssh_setup, *rules_dev_main]
  needs: ["test-dev"]
  script:
    - echo "ğŸ›¡ï¸  PRE-DEPLOYMENT SAFETY VALIDATION"
    - |
      ssh "ubuntu@$DEPLOY_SERVER_DEV" '
        cd ~/bgTest/v5ToWindow 2>/dev/null || cd ~
        
        echo "ğŸ” â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        echo "ğŸ›¡ï¸  PRE-DEPLOYMENT SAFETY VALIDATION PROTOCOL"
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        
        # Validation 1: System Resource Check
        echo "ğŸ” Validation 1: System Resources"
        
        # Memory check
        MEMORY_FREE=$(free -m | awk '"'NR==2{printf "%.0f", $7*100/$2}"')
        DISK_FREE=$(df -h / | awk '"'NR==2{gsub(/%/,"", $5); print 100-$5}"')
        
        echo "   Available Memory: ${MEMORY_FREE}%"
        echo "   Available Disk: ${DISK_FREE}%"
        
        if [ "$MEMORY_FREE" -lt 10 ]; then
          echo "âŒ Critical: Low memory (${MEMORY_FREE}% available)"
          echo "   Deployment may fail due to insufficient memory"
          exit 1
        fi
        
        if [ "$DISK_FREE" -lt 10 ]; then
          echo "âŒ Critical: Low disk space (${DISK_FREE}% available)"
          echo "   Deployment may fail due to insufficient disk space"
          exit 1
        fi
        
        echo "âœ… Resource check passed"
        
        # Validation 2: Docker System Health
        echo ""
        echo "ğŸ” Validation 2: Docker System Health"
        
        # Check Docker daemon
        if ! docker version >/dev/null 2>&1; then
          echo "âŒ Critical: Docker daemon is not accessible"
          echo "   Cannot proceed with containerized deployment"
          exit 1
        fi
        
        # Check Docker space
        DOCKER_SPACE=$(docker system df --format "table {{.Type}}\t{{.Size}}" | grep -v TYPE | awk '"{sum+=$2} END {print sum/1024/1024/1024}"' 2>/dev/null || echo "0")
        echo "   Docker space usage: ${DOCKER_SPACE}GB"
        
        # Check for dangling images/containers that might cause issues
        DANGLING_IMAGES=$(docker images --filter "dangling=true" -q | wc -l)
        STOPPED_CONTAINERS=$(docker ps -a --filter "status=exited" -q | wc -l)
        
        echo "   Dangling images: $DANGLING_IMAGES"
        echo "   Stopped containers: $STOPPED_CONTAINERS"
        
        if [ "$DANGLING_IMAGES" -gt 10 ]; then
          echo "âš ï¸  Warning: Many dangling images detected - consider cleanup"
        fi
        
        echo "âœ… Docker system check passed"
        
        # Validation 3: Network Connectivity
        echo ""
        echo "ğŸ” Validation 3: Network Connectivity"
        
        # Check if bluegreen network exists and is functional
        if docker network ls | grep -q bluegreen-network; then
          echo "âœ… Blue-Green network exists"
          
          # Test network connectivity between containers (if they exist)
          if docker ps --format "{{.Names}}" | grep -q nginx-proxy; then
            echo "   Testing inter-container connectivity..."
            # Test nginx to app connectivity
            if docker exec nginx-proxy nslookup blue-app >/dev/null 2>&1 && docker exec nginx-proxy nslookup green-app >/dev/null 2>&1; then
              echo "âœ… Container DNS resolution working"
            else
              echo "âš ï¸  Container DNS resolution issues detected"
            fi
          fi
        else
          echo "â„¹ï¸  Blue-Green network not found (will be created during deployment)"
        fi
        
        # Validation 4: Port Availability
        echo ""
        echo "ğŸ” Validation 4: Port Availability"
        
        # Check if critical ports are available or properly used
        PORT_80_USED=$(netstat -tuln 2>/dev/null | grep ":80 " || echo "")
        
        if [ -n "$PORT_80_USED" ]; then
          # Port 80 is used - check if it'"'s our nginx
          if docker ps --format "{{.Names}}\t{{.Ports}}" | grep nginx-proxy | grep -q "80->80"; then
            echo "âœ… Port 80 correctly used by nginx-proxy"
          else
            echo "âš ï¸  Port 80 is used by unknown process: $PORT_80_USED"
            echo "   This might cause deployment conflicts"
          fi
        else
          echo "âœ… Port 80 available for deployment"
        fi
        
        # Validation 5: Previous Deployment State
        echo ""
        echo "ğŸ” Validation 5: Previous Deployment State"
        
        # Check if there'"'s any stuck or failed deployment
        if [ -f "deployment_state/deployment.lock" ]; then
          LOCK_AGE=$(find deployment_state/deployment.lock -mmin +30 2>/dev/null || echo "")
          if [ -n "$LOCK_AGE" ]; then
            echo "âš ï¸  Stale deployment lock detected (>30 minutes old)"
            echo "   Removing stale lock to proceed"
            rm -f deployment_state/deployment.lock
          else
            echo "âŒ Active deployment lock detected"
            echo "   Another deployment may be in progress"
            echo "   Wait for completion or investigate manually"
            exit 1
          fi
        fi
        
        # Create deployment lock
        mkdir -p deployment_state
        echo "$(date): Pre-deployment validation passed" > deployment_state/deployment.lock
        
        echo "âœ… Deployment state check passed"
        
        # Summary
        echo ""
        echo "ğŸ† PRE-DEPLOYMENT VALIDATION SUMMARY:"
        echo "   âœ… System Resources: Adequate"
        echo "   âœ… Docker System: Healthy  "
        echo "   âœ… Network: Ready"
        echo "   âœ… Ports: Available"
        echo "   âœ… Deployment State: Clean"
        echo ""
        echo "âœ… All validations passed - deployment can proceed safely"
        
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
      '

# 3. Environment Detection
detect-active-environment:
  stage: detect-env-dev
  image: alpine:latest
  <<: [*ssh_setup, *rules_dev_main]
  needs: ["build-dev", "test-dev", "pre-deployment-validation"]
  script:
#    - set -x  # ëª¨ë“  ëª…ë ¹ì–´ ì¶œë ¥
    - echo "ğŸ” Detecting current active environment..."
    - |
      ssh "ubuntu@$DEPLOY_SERVER_DEV" '
        cd ~/bgTest/v5ToWindow
        echo "ğŸ“Š Environment Detection:"
        
        # ENHANCED MULTI-SOURCE ENVIRONMENT DETECTION
        echo "ğŸ” Enhanced environment detection with multiple validation sources..."
        
        # Initialize detection variables
        CURRENT_ACTIVE="unknown"
        DEPLOY_TARGET="unknown"
        DETECTION_CONFIDENCE="low"
        DETECTION_SOURCES=""
        
        # Multi-layer system check
        if docker ps --filter "name=nginx-proxy" --format "{{.Names}}" 2>/dev/null | grep -q "^nginx-proxy$"; then
          echo "âœ… Blue-Green system is confirmed running"
          
          # Source 1: API-based detection (highest priority)
          echo "ğŸ” Source 1: Querying API server for current deployment..."
          API_RESPONSE=$(docker run --rm --network bluegreen-network curlimages/curl:latest \
            curl -s --max-time 10 "http://api-server:9000/status" 2>/dev/null || echo '{"error":"api_unreachable"}')
          API_ACTIVE=$(echo "$API_RESPONSE" | jq -r ".current_deployment" 2>/dev/null || echo "")
          
          if [ -n "$API_ACTIVE" ] && [ "$API_ACTIVE" != "null" ] && [ "$API_ACTIVE" != "" ]; then
            if [ "$API_ACTIVE" = "blue" ] || [ "$API_ACTIVE" = "green" ]; then
              CURRENT_ACTIVE="$API_ACTIVE"
              DETECTION_CONFIDENCE="high"
              DETECTION_SOURCES="api"
              echo "âœ… Source 1 SUCCESS: API reports current active: $API_ACTIVE"
            fi
          else
            echo "âš ï¸  Source 1 FAILED: API detection unsuccessful"
          fi
          
          # Source 2: File-based detection (medium priority)
          if [ "$CURRENT_ACTIVE" = "unknown" ]; then
            echo "ğŸ” Source 2: Checking active.env file configuration..."
            FILE_ACTIVE=$(docker exec nginx-proxy cat /etc/nginx/conf.d/active.env 2>/dev/null | grep -o "blue\|green" | head -1 || echo "")
            
            if [ -n "$FILE_ACTIVE" ] && [ "$FILE_ACTIVE" != "" ]; then
              CURRENT_ACTIVE="$FILE_ACTIVE"
              DETECTION_CONFIDENCE="medium"
              DETECTION_SOURCES="file"
              echo "âœ… Source 2 SUCCESS: File reports current active: $FILE_ACTIVE"
            else
              echo "âš ï¸  Source 2 FAILED: File detection unsuccessful"
            fi
          else
            echo "â„¹ï¸  Source 2 SKIPPED: Already detected via API"
          fi
          
          # Source 3: Container health analysis (lowest priority)
          if [ "$CURRENT_ACTIVE" = "unknown" ]; then
            echo "ğŸ” Source 3: Analyzing container health patterns..."
            BLUE_STATUS=$(docker inspect --format='{{.State.Health.Status}}' blue-app 2>/dev/null || echo "unknown")
            GREEN_STATUS=$(docker inspect --format='{{.State.Health.Status}}' green-app 2>/dev/null || echo "unknown")
            
            echo "   Blue container health: $BLUE_STATUS"
            echo "   Green container health: $GREEN_STATUS"
            
            # Heuristic: The healthier container is likely the active one
            if [ "$BLUE_STATUS" = "healthy" ] && [ "$GREEN_STATUS" != "healthy" ]; then
              CURRENT_ACTIVE="blue"
              DETECTION_CONFIDENCE="low"
              DETECTION_SOURCES="health-heuristic"
              echo "âœ… Source 3 HEURISTIC: Blue appears active (healthier)"
            elif [ "$GREEN_STATUS" = "healthy" ] && [ "$BLUE_STATUS" != "healthy" ]; then
              CURRENT_ACTIVE="green"
              DETECTION_CONFIDENCE="low"
              DETECTION_SOURCES="health-heuristic"
              echo "âœ… Source 3 HEURISTIC: Green appears active (healthier)"
            else
              echo "âš ï¸  Source 3 FAILED: Cannot determine from health status"
            fi
          else
            echo "â„¹ï¸  Source 3 SKIPPED: Already detected via higher priority source"
          fi
          
          # Determine deployment target based on detected active environment
          if [ "$CURRENT_ACTIVE" != "unknown" ]; then
            if [ "$CURRENT_ACTIVE" = "blue" ]; then
              DEPLOY_TARGET="green"
              echo "ğŸ”µâ†’ğŸŸ¢ TRUE BLUE-GREEN: Active=blue, Target=green"
            else
              DEPLOY_TARGET="blue"
              echo "ğŸŸ¢â†’ğŸ”µ TRUE BLUE-GREEN: Active=green, Target=blue"
            fi
          else
            # Safe fallback with explicit logging
            echo "ğŸ›¡ï¸  SAFE FALLBACK: Unable to detect active environment"
            echo "   Defaulting to green deployment with blue assumed active"
            CURRENT_ACTIVE="blue"
            DEPLOY_TARGET="green"
            DETECTION_CONFIDENCE="fallback"
            DETECTION_SOURCES="fallback"
          fi
          
        else
          echo "ğŸ—ï¸  FIRST DEPLOYMENT: System not detected, initializing green environment"
          CURRENT_ACTIVE="none"
          DEPLOY_TARGET="green"
          DETECTION_CONFIDENCE="initialization"
          DETECTION_SOURCES="initialization"
        fi
        
        # Comprehensive environment summary
        echo ""
        echo "ğŸ“Š ENVIRONMENT DETECTION SUMMARY:"
        echo "   Current Active: $CURRENT_ACTIVE"
        echo "   Deploy Target: $DEPLOY_TARGET"
        echo "   Detection Confidence: $DETECTION_CONFIDENCE"
        echo "   Detection Method: $DETECTION_SOURCES"
        echo ""
        
        # Save environment info with metadata
        echo "$CURRENT_ACTIVE" > ~/current_active.env
        echo "$DEPLOY_TARGET" > ~/deploy_target.env
        echo "$DETECTION_CONFIDENCE" > ~/detection_confidence.env
        echo "$DETECTION_SOURCES" > ~/detection_sources.env
        
        # Validation checkpoint
        if [ "$DEPLOY_TARGET" = "unknown" ]; then
          echo "âŒ CRITICAL ERROR: Could not determine deployment target"
          echo "   This indicates a severe environment detection failure"
          exit 1
        fi
      '

# 4. Deploy to Inactive Environment ONLY (ZERO DOWNTIME).
deploy-to-inactive-environment:
  stage: deploy-inactive-dev
  image: alpine:latest
  <<: [*ssh_setup, *rules_dev_main]
  needs: ["detect-active-environment"]
  environment:
    name: inactive-env
    url: "http://$DEPLOY_SERVER_DEV"
  script:
    - echo "ğŸš€ TRUE BLUE-GREEN DEPLOYMENT - Deploy to inactive environment only"
    - echo "ğŸ“ Transferring unified service architecture..."
    - ssh "ubuntu@$DEPLOY_SERVER_DEV" "mkdir -p ~/bgTest/v5ToWindow"
    - scp -r ./app-service/ "ubuntu@$DEPLOY_SERVER_DEV:~/bgTest/v5ToWindow/"
    - scp -r ./api-service/ "ubuntu@$DEPLOY_SERVER_DEV:~/bgTest/v5ToWindow/"
    - scp -r ./api-server/ "ubuntu@$DEPLOY_SERVER_DEV:~/bgTest/v5ToWindow/"
    - scp -r ./monitoring/ "ubuntu@$DEPLOY_SERVER_DEV:~/bgTest/v5ToWindow/"
    - scp -r ./app-server/ "ubuntu@$DEPLOY_SERVER_DEV:~/bgTest/v5ToWindow/"
    - ssh "ubuntu@$DEPLOY_SERVER_DEV" "mkdir -p ~/bgTest/v5ToWindow/conf.d"
    - scp ./conf.d/upstreams.conf "ubuntu@$DEPLOY_SERVER_DEV:~/bgTest/v5ToWindow/conf.d/"
    - scp ./conf.d/routing.conf "ubuntu@$DEPLOY_SERVER_DEV:~/bgTest/v5ToWindow/conf.d/"
    - scp ./docker-compose.yml "ubuntu@$DEPLOY_SERVER_DEV:~/bgTest/v5ToWindow/"
    - scp ./nginx.conf "ubuntu@$DEPLOY_SERVER_DEV:~/bgTest/v5ToWindow/"
    - scp ./admin.html "ubuntu@$DEPLOY_SERVER_DEV:~/bgTest/v5ToWindow/"
    - scp ./.env "ubuntu@$DEPLOY_SERVER_DEV:~/bgTest/v5ToWindow/" || echo "No .env file found, using defaults"
    - echo "ğŸ³ Deploying ONLY to inactive environment (maintaining zero downtime)..."
    - |
      ssh "ubuntu@$DEPLOY_SERVER_DEV" '
        cd ~/bgTest/v5ToWindow
        
        # True Blue-Green deployment: Deploy to inactive environment
        DEPLOY_TARGET=$(cat ~/deploy_target.env 2>/dev/null || echo "green")
        DEPLOY_VERSION="'${DEPLOYMENT_VERSION}'"
        echo "ğŸ¯ Deploying version $DEPLOY_VERSION to $DEPLOY_TARGET environment (True Blue-Green mode)"
        
        # Set version for target environment (True Blue-Green mode)
        if [ "$DEPLOY_TARGET" = "blue" ]; then
          export BLUE_VERSION="$DEPLOY_VERSION"
          echo "BLUE_VERSION=$DEPLOY_VERSION" >> .env
          echo "ğŸ”µ True Blue-Green: Setting BLUE_VERSION=$DEPLOY_VERSION"
        else
          export GREEN_VERSION="$DEPLOY_VERSION"
          echo "GREEN_VERSION=$DEPLOY_VERSION" >> .env
          echo "ğŸŸ¢ True Blue-Green: Setting GREEN_VERSION=$DEPLOY_VERSION"
        fi
        
        # Ensure deployment metadata directory exists
        mkdir -p deployment_state
        
        # Install Docker if needed
        if ! command -v docker &> /dev/null; then
          echo "ğŸ“¦ Installing Docker..."
          curl -fsSL https://get.docker.com -o get-docker.sh
          sudo sh get-docker.sh
          sudo usermod -aG docker ubuntu
          sudo systemctl start docker
          sudo systemctl enable docker
        fi
        
        # Ensure Docker permissions and restart if needed
        sudo usermod -aG docker ubuntu
        sudo systemctl restart docker
        sudo chmod 666 /var/run/docker.sock || true
        newgrp docker || true
        
        # Install debugging tools
        sudo apt-get update -qq >/dev/null 2>&1 || true
        sudo apt-get install -y netcat-openbsd net-tools >/dev/null 2>&1 || true
        
        # Install Docker Compose if needed
        if ! command -v docker-compose &> /dev/null; then
          echo "ğŸ“¦ Installing Docker Compose..."
          sudo curl -L "https://github.com/docker/compose/releases/download/v2.24.0/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
          sudo chmod +x /usr/local/bin/docker-compose
          sudo ln -sf /usr/local/bin/docker-compose /usr/bin/docker-compose
        fi
        
        # Verify Docker is accessible
        echo "ğŸ” Verifying Docker access..."
        if ! docker ps >/dev/null 2>&1 && ! sudo docker ps >/dev/null 2>&1; then
          echo "âŒ Docker is not accessible. Please check Docker installation and permissions."
          exit 1
        fi
        
        # ENHANCED MULTI-LAYER SYSTEM DETECTION (Zero-Downtime Critical)
        SYSTEM_RUNNING=false
        DETECTION_METHOD="none"
        
        echo "ğŸ” Multi-layer system detection starting..."
        
        # Layer 1: Container existence check
        if docker ps --filter "name=nginx-proxy" --format "{{.Names}}" 2>/dev/null | grep -q "^nginx-proxy$"; then
          echo "âœ… Layer 1: nginx-proxy container exists"
          
          # Layer 2: Container inspection
          if docker container inspect nginx-proxy >/dev/null 2>&1; then
            echo "âœ… Layer 2: nginx-proxy container accessible"
            
            # Layer 3: Process verification
            if docker exec nginx-proxy ps aux 2>/dev/null | grep -q "nginx: master process" || docker exec nginx-proxy pgrep nginx >/dev/null 2>&1; then
              echo "âœ… Layer 3: nginx process running inside container"
              SYSTEM_RUNNING=true
              DETECTION_METHOD="multi-layer"
            fi
          fi
        fi
        
        # Additional validation: API server accessibility (if system seems to be running)
        if [ "$SYSTEM_RUNNING" = "true" ]; then
          echo "ğŸ” Layer 4: Validating API server accessibility..."
          if docker run --rm --network bluegreen-network curlimages/curl:latest curl -s --max-time 5 "http://api-server:9000/health" >/dev/null 2>&1; then
            echo "âœ… Layer 4: API server responsive"
            DETECTION_METHOD="api-validated"
          else
            echo "âš ï¸  Layer 4: API server not responsive, but container system detected"
          fi
        fi
        
        if [ "$SYSTEM_RUNNING" = "true" ]; then
          echo "ğŸ¯ ZERO-DOWNTIME MODE: System detected via $DETECTION_METHOD method"
          echo "âœ… Deploying ONLY to inactive $DEPLOY_TARGET environment"
          
          # TRUE ZERO-DOWNTIME DEPLOYMENT - TARGET CONTAINER ONLY
          echo "ğŸ”„ Zero-downtime deployment to $DEPLOY_TARGET environment..."
          
          # Check if API server needs rebuild (only if unhealthy)
          API_STATUS=$(docker inspect --format='{{.State.Health.Status}}' api-server 2>/dev/null || echo "unhealthy")
          if [ "$API_STATUS" != "healthy" ]; then
            echo "ğŸ”§ API server unhealthy, rebuilding with zero-downtime..."
            docker-compose -f docker-compose.yml build api-server || sudo docker-compose -f docker-compose.yml build api-server
            docker-compose -f docker-compose.yml up -d --no-deps api-server || sudo docker-compose -f docker-compose.yml up -d --no-deps api-server
          else
            echo "âœ… API server healthy, skipping rebuild"
          fi
          
          # Rebuild ONLY target application environment (True Blue-Green)
          echo "ğŸ¯ Rebuilding ONLY $DEPLOY_TARGET application environment..."
          docker-compose -f docker-compose.yml build ${DEPLOY_TARGET}-app || sudo docker-compose -f docker-compose.yml build ${DEPLOY_TARGET}-app
          docker-compose -f docker-compose.yml up -d --no-deps --force-recreate ${DEPLOY_TARGET}-app || sudo docker-compose -f docker-compose.yml up -d --no-deps --force-recreate ${DEPLOY_TARGET}-app
          
          echo "â³ Waiting for $DEPLOY_TARGET environment to be ready..."
          sleep 30  # Reduced wait time for single container
          
          # Verify target environment accessibility
          echo "ğŸ” Verifying $DEPLOY_TARGET environment accessibility..."
          TARGET_PORT=$(if [ "$DEPLOY_TARGET" = "blue" ]; then echo "3001"; else echo "3002"; fi)
          for attempt in $(seq 1 10); do
            if docker exec "${DEPLOY_TARGET}-app" curl -s --max-time 3 "http://localhost:$TARGET_PORT/health" >/dev/null 2>&1; then
              echo "âœ… $DEPLOY_TARGET environment is responsive (attempt $attempt/10)"
              break
            else
              echo "â³ $DEPLOY_TARGET environment not ready yet (attempt $attempt/10)..."
              sleep 5
            fi
            if [ $attempt -eq 10 ]; then
              echo "âŒ $DEPLOY_TARGET environment failed to become ready after 10 attempts"
              echo "ğŸ” Container status:"
              docker ps --filter "name=${DEPLOY_TARGET}-app"
              echo "ğŸ” $DEPLOY_TARGET environment logs:"
              docker logs "${DEPLOY_TARGET}-app" --tail 50 || true
              exit 1
            fi
          done
          
        else
          echo "ğŸ›¡ï¸  SAFE MODE: System detection failed - Manual validation required"
          echo ""
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ğŸš¨ DEPLOYMENT SAFETY PROTOCOL ACTIVATED"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo ""
          echo "ğŸ” CURRENT SYSTEM STATE:"
          echo "$(docker ps --all --format 'table {{.Names}}\t{{.Status}}\t{{.CreatedAt}}\t{{.Ports}}' 2>/dev/null || echo 'Docker not accessible')"
          echo ""
          echo "ğŸ“‹ DETECTION FAILURE ANALYSIS:"
          echo "   â€¢ nginx-proxy container: $(docker ps --filter 'name=nginx-proxy' --format '{{.Status}}' 2>/dev/null || echo 'Not found/accessible')"
          echo "   â€¢ Docker daemon: $(docker version --format '{{.Server.Version}}' 2>/dev/null || echo 'Not accessible')"
          echo "   â€¢ Network: $(docker network ls --filter 'name=bluegreen-network' --format '{{.Name}}' 2>/dev/null || echo 'Not accessible')"
          echo ""
          echo "âš ï¸  SAFETY REASONS FOR STOPPING:"
          echo "   â€¢ Cannot reliably detect system state"
          echo "   â€¢ Risk of causing service downtime"
          echo "   â€¢ Potential data consistency issues"
          echo ""
          echo "ğŸ”§ RECOMMENDED ACTIONS:"
          echo "   1. Verify Docker daemon is running: sudo systemctl status docker"
          echo "   2. Check container states manually: docker ps -a"
          echo "   3. Verify network connectivity: docker network inspect bluegreen-network"
          echo "   4. Check system resources: free -h && df -h"
          echo "   5. Review recent logs: journalctl -u docker --since '10 minutes ago'"
          echo ""
          echo "ğŸš€ TO PROCEED MANUALLY:"
          echo "   â€¢ If system is truly not running, initialize it manually"
          echo "   â€¢ If system is running, investigate detection failure"
          echo "   â€¢ Re-run pipeline after resolving the issue"
          echo ""
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "âŒ DEPLOYMENT ABORTED FOR SAFETY"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          exit 1
        fi
        
        # Enhanced Docker-native health checking with internal network validation
        echo "ğŸ¥ Health checking deployed $DEPLOY_TARGET environment with Docker-native methods..."
        TARGET_PORT=$(if [ "$DEPLOY_TARGET" = "blue" ]; then echo "3001"; else echo "3002"; fi)
        APP_CONTAINER="${DEPLOY_TARGET}-app"
        
        # ENHANCED MULTI-LAYER HEALTH VALIDATION SYSTEM
        
        # Helper function: Get comprehensive Docker health status
        get_docker_health_status() {
          local container="$1"
          if docker inspect --format='{{json .State.Health}}' "$container" >/dev/null 2>&1; then
            local health_status=$(docker inspect --format='{{.State.Health.Status}}' "$container" 2>/dev/null || echo "no-health")
            local health_checks=$(docker inspect --format='{{len .State.Health.Log}}' "$container" 2>/dev/null || echo "0")
            echo "${health_status}:${health_checks}"
          else
            echo "no-health:0"
          fi
        }
        
        # Helper function: Internal container health check with detailed validation
        app_internal_health_check() {
          local container="$1"
          local port="$2"
          local max_attempts=3
          
          for attempt in $(seq 1 $max_attempts); do
            # Check 1: Basic health endpoint
            if docker exec "$container" curl -sS -f --max-time 5 "http://localhost:$port/health" >/dev/null 2>&1; then
              # Check 2: Version endpoint (validates application logic)
              if docker exec "$container" curl -sS --max-time 3 "http://localhost:$port/version" | jq -e '.version' >/dev/null 2>&1; then
                # Check 3: Process validation
                if docker exec "$container" pgrep node >/dev/null 2>&1; then
                  echo "SUCCESS:internal:$attempt"
                  return 0
                fi
              fi
            fi
            [ $attempt -lt $max_attempts ] && sleep 2
          done
          echo "FAILED:internal:$max_attempts"
          return 1
        }
        
        # Helper function: Network-level health check via ephemeral container
        network_health_check() {
          local container="$1"
          local port="$2"
          local max_attempts=3
          
          for attempt in $(seq 1 $max_attempts); do
            # Network connectivity test
            if docker run --rm --network bluegreen-network curlimages/curl:latest \
              curl -sS -f --max-time 5 "http://${container}:${port}/health" >/dev/null 2>&1; then
              echo "SUCCESS:network:$attempt"
              return 0
            fi
            [ $attempt -lt $max_attempts ] && sleep 2
          done
          echo "FAILED:network:$max_attempts"
          return 1
        }
        
        # Helper function: Business logic validation
        business_logic_check() {
          local container="$1"
          local port="$2"
          
          # Test critical endpoints that validate business functionality
          local endpoints="/health /version /status"
          local passed=0
          local total=0
          
          for endpoint in $endpoints; do
            total=$((total + 1))
            if docker exec "$container" curl -sS --max-time 3 "http://localhost:$port$endpoint" >/dev/null 2>&1; then
              passed=$((passed + 1))
              echo "   âœ… $endpoint: responsive"
            else
              echo "   âŒ $endpoint: failed"
            fi
          done
          
          local success_rate=$(echo "scale=0; $passed * 100 / $total" | bc -l 2>/dev/null || echo "0")
          if [ $success_rate -ge 66 ]; then  # At least 2/3 endpoints must pass
            echo "SUCCESS:business:${success_rate}%"
            return 0
          else
            echo "FAILED:business:${success_rate}%"
            return 1
          fi
        }
        
        # Helper function: Resource validation
        resource_health_check() {
          local container="$1"
          
          # Memory usage check
          local memory_usage=$(docker stats --no-stream --format "{{.MemPerc}}" "$container" 2>/dev/null | sed 's/%//' || echo "0")
          # CPU usage check (average over 5 seconds)
          local cpu_usage=$(docker stats --no-stream --format "{{.CPUPerc}}" "$container" 2>/dev/null | sed 's/%//' || echo "0")
          
          # Resource thresholds
          local memory_threshold=90
          local cpu_threshold=80
          
          if [ "$(echo "$memory_usage < $memory_threshold" | bc -l 2>/dev/null || echo 0)" = "1" ] && \
             [ "$(echo "$cpu_usage < $cpu_threshold" | bc -l 2>/dev/null || echo 0)" = "1" ]; then
            echo "SUCCESS:resources:mem=${memory_usage}%,cpu=${cpu_usage}%"
            return 0
          else
            echo "WARNING:resources:mem=${memory_usage}%,cpu=${cpu_usage}%"
            return 1
          fi
        }
        
        # COMPREHENSIVE MULTI-LAYER HEALTH VALIDATION
        echo "ğŸ¡ Starting comprehensive health validation for $DEPLOY_TARGET environment..."
        
        local health_passed=false
        local validation_score=0
        local max_score=5  # 5 validation layers
        
        for attempt in $(seq 1 30); do
          echo ""
          echo "ğŸ” â”â”â” Health Validation Attempt $attempt/30 â”â”â”"
          echo "   Target: $DEPLOY_TARGET (container: $APP_CONTAINER, port: $TARGET_PORT)"
          
          validation_score=0
          local validation_details=""
          
          # Layer 1: Docker Container Health Status
          echo "ğŸ” Layer 1: Docker Health Status"
          HEALTH_STATUS_RESULT=$(get_docker_health_status "$APP_CONTAINER")
          HEALTH_STATUS=$(echo "$HEALTH_STATUS_RESULT" | cut -d':' -f1)
          HEALTH_CHECKS=$(echo "$HEALTH_STATUS_RESULT" | cut -d':' -f2)
          
          if [ "$HEALTH_STATUS" = "healthy" ]; then
            validation_score=$((validation_score + 1))
            validation_details="${validation_details}[Docker:âœ…]"
            echo "   âœ… Docker health: $HEALTH_STATUS ($HEALTH_CHECKS checks)"
          else
            validation_details="${validation_details}[Docker:âŒ]"
            echo "   âŒ Docker health: $HEALTH_STATUS"
          fi
          
          # Layer 2: Internal Application Health
          echo "ğŸ” Layer 2: Internal Application Health"
          INTERNAL_RESULT=$(app_internal_health_check "$APP_CONTAINER" "$TARGET_PORT")
          if echo "$INTERNAL_RESULT" | grep -q "SUCCESS"; then
            validation_score=$((validation_score + 1))
            validation_details="${validation_details}[Internal:âœ…]"
            echo "   âœ… Internal health: $(echo "$INTERNAL_RESULT" | cut -d':' -f3) attempts"
          else
            validation_details="${validation_details}[Internal:âŒ]"
            echo "   âŒ Internal health: $(echo "$INTERNAL_RESULT" | cut -d':' -f3) attempts failed"
          fi
          
          # Layer 3: Network Connectivity
          echo "ğŸ” Layer 3: Network Connectivity"
          NETWORK_RESULT=$(network_health_check "$APP_CONTAINER" "$TARGET_PORT")
          if echo "$NETWORK_RESULT" | grep -q "SUCCESS"; then
            validation_score=$((validation_score + 1))
            validation_details="${validation_details}[Network:âœ…]"
            echo "   âœ… Network health: $(echo "$NETWORK_RESULT" | cut -d':' -f3) attempts"
          else
            validation_details="${validation_details}[Network:âŒ]"
            echo "   âŒ Network health: $(echo "$NETWORK_RESULT" | cut -d':' -f3) attempts failed"
          fi
          
          # Layer 4: Business Logic Validation
          echo "ğŸ” Layer 4: Business Logic Validation"
          BUSINESS_RESULT=$(business_logic_check "$APP_CONTAINER" "$TARGET_PORT")
          if echo "$BUSINESS_RESULT" | grep -q "SUCCESS"; then
            validation_score=$((validation_score + 1))
            validation_details="${validation_details}[Business:âœ…]"
            echo "   âœ… Business logic: $(echo "$BUSINESS_RESULT" | cut -d':' -f3)"
          else
            validation_details="${validation_details}[Business:âŒ]"
            echo "   âŒ Business logic: $(echo "$BUSINESS_RESULT" | cut -d':' -f3)"
          fi
          
          # Layer 5: Resource Health
          echo "ğŸ” Layer 5: Resource Health"
          RESOURCE_RESULT=$(resource_health_check "$APP_CONTAINER")
          if echo "$RESOURCE_RESULT" | grep -q "SUCCESS"; then
            validation_score=$((validation_score + 1))
            validation_details="${validation_details}[Resources:âœ…]"
            echo "   âœ… Resource health: $(echo "$RESOURCE_RESULT" | cut -d':' -f3)"
          elif echo "$RESOURCE_RESULT" | grep -q "WARNING"; then
            validation_score=$((validation_score + 1))  # Count warning as partial success
            validation_details="${validation_details}[Resources:âš ï¸]"
            echo "   âš ï¸  Resource warning: $(echo "$RESOURCE_RESULT" | cut -d':' -f3)"
          else
            validation_details="${validation_details}[Resources:âŒ]"
            echo "   âŒ Resource health: Failed"
          fi
          
          # Calculate validation percentage
          local validation_percentage=$(echo "scale=0; $validation_score * 100 / $max_score" | bc -l 2>/dev/null || echo "0")
          echo "   ğŸ“ˆ Validation Score: $validation_score/$max_score ($validation_percentage%)"
          echo "   ğŸ“Š Status Summary: $validation_details"
          
          # Success criteria: At least 80% of validations must pass (4/5)
          if [ $validation_score -ge 4 ]; then
            echo ""
            echo "âœ… ğŸ† HEALTH VALIDATION SUCCESSFUL! ğŸ†"
            echo "   Score: $validation_score/$max_score ($validation_percentage%)"
            echo "   Details: $validation_details"
            
            # Get and display version information
            DEPLOYED_VERSION=$(docker exec "$APP_CONTAINER" sh -c "curl -s --max-time 3 http://localhost:$TARGET_PORT/version 2>/dev/null | jq -r .version 2>/dev/null" || echo "unknown")
            DEPLOYMENT_ID=$(docker exec "$APP_CONTAINER" sh -c "curl -s --max-time 3 http://localhost:$TARGET_PORT/version 2>/dev/null | jq -r .deployment_id 2>/dev/null" || echo "unknown")
            
            echo "   ğŸ“ Version: $DEPLOYED_VERSION"
            echo "   ğŸ†” Deployment ID: $DEPLOYMENT_ID"
            
            health_passed=true
            break
          fi
          
          # Enhanced debugging at key intervals
          if [ $attempt -eq 5 ] || [ $attempt -eq 15 ] || [ $attempt -eq 25 ]; then
            echo ""
            echo "ğŸ” [DIAGNOSTIC] Deep Analysis (attempt $attempt):"
            echo "   Container State:"
            docker ps -a --format "   {{.Names}}\t{{.Status}}\t{{.Ports}}" | grep -E "(${DEPLOY_TARGET}|api|nginx)" || true
            echo "   Recent Logs:"
            docker logs --tail 10 "$APP_CONTAINER" 2>&1 | sed 's/^/   /' || echo "   No logs available"
            echo "   Network Test:"
            docker exec "$APP_CONTAINER" sh -c "netstat -tulpn 2>/dev/null | grep :$TARGET_PORT || echo '   Port not bound'" | sed 's/^/   /'
          fi
          
          # Progressive backoff with jitter
          if [ $attempt -lt 30 ]; then
            sleep_duration=$(( 3 + attempt / 3 ))
            if [ $sleep_duration -gt 15 ]; then sleep_duration=15; fi
            echo "   â³ Waiting ${sleep_duration}s (progressive backoff)..."
            sleep "$sleep_duration"
          fi
        done
        
        # Final validation result
        if [ "$health_passed" = "false" ]; then
          echo ""
          echo "âŒ ğŸš¨ HEALTH VALIDATION FAILED! ğŸš¨"
          echo "   Final Score: $validation_score/$max_score ($validation_percentage%)"
          echo "   Details: $validation_details"
          echo ""
          echo "ğŸ” [FINAL DIAGNOSTIC] Complete system state:"
          docker ps -a --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}\t{{.CreatedAt}}"
          echo ""
          echo "ğŸ“œ Final logs from $APP_CONTAINER:"
          docker logs --tail 30 "$APP_CONTAINER" 2>&1 || echo "No logs available"
          echo ""
          echo "ğŸŒ Network diagnostics:"
          docker network inspect bluegreen-network | jq '.[0].Containers' 2>/dev/null || echo "Network inspection failed"
          exit 1
        fi
        
        echo "ğŸ‰ Inactive environment deployment completed successfully with version tracking!"
      '

# 5. Health Check Inactive Environment
health-check-inactive-environment:
  stage: health-check-dev
  image: alpine:latest
  <<: [*ssh_setup, *rules_dev_main]
  needs: ["deploy-to-inactive-environment"]
  retry: 2
  script:
    - echo "ğŸ¥ Comprehensive Docker-native health check of inactive environment..."
    - |
      ssh "ubuntu@$DEPLOY_SERVER_DEV" '
        cd ~/bgTest/v5ToWindow
        DEPLOY_TARGET=$(cat ~/deploy_target.env 2>/dev/null || echo "green")
        echo "ğŸ¯ Health checking $DEPLOY_TARGET environment using Docker-native methods..."
        
        APP_CONTAINER="${DEPLOY_TARGET}-app"
        TARGET_PORT=$(if [ "$DEPLOY_TARGET" = "blue" ]; then echo "3001"; else echo "3002"; fi)
        
        # Enhanced service health check with multiple validation layers
        check_service_enhanced() {
          local service_name="$1"
          local container_name="$2"
          local internal_port="$3"
          local proxy_url="$4"
          local max_attempts=12
          
          echo "ğŸ” Enhanced health check for $service_name (container: $container_name)..."
          
          for attempt in $(seq 1 $max_attempts); do
            echo "ğŸ” Attempt $attempt/$max_attempts for $service_name"
            
            # Method 1: Docker health status (if available)
            if docker inspect --format="{{.State.Health.Status}}" "$container_name" 2>/dev/null | grep -q "healthy"; then
              echo "âœ… $service_name: Docker health status = healthy"
              return 0
            fi
            
            # Method 2: Internal container health check
            if [ -n "$internal_port" ] && docker exec "$container_name" sh -c "curl -sS -f --max-time 3 http://localhost:$internal_port/health >/dev/null" 2>/dev/null; then
              echo "âœ… $service_name: Internal health check passed"
              return 0
            fi
            
            # Method 3: Network-level health check via ephemeral container
            if docker run --rm --network bluegreen-network curlimages/curl:latest -sS -f --max-time 3 "http://$container_name:$internal_port/health" >/dev/null 2>/dev/null; then
              echo "âœ… $service_name: Network-level health check passed"
              return 0
            fi
            
            # Method 4: Proxy-based health check (fallback for NGINX routing validation)
            if [ -n "$proxy_url" ] && curl -sS -f --max-time 3 "$proxy_url" >/dev/null 2>/dev/null; then
              echo "âœ… $service_name: Proxy-based health check passed"
              return 0
            fi
            
            # Progressive wait with exponential backoff
            wait_time=$(( 2 + attempt ))
            if [ $wait_time -gt 15 ]; then wait_time=15; fi
            echo "â³ $service_name not ready, waiting ${wait_time}s... ($attempt/$max_attempts)"
            sleep "$wait_time"
          done
          
          echo "âŒ $service_name health check failed after $max_attempts attempts"
          return 1
        }
        
        # Check core services with enhanced validation
        overall_status=0
        
        # Check target environment (blue or green) with comprehensive validation
        echo "ğŸ¯ Checking target environment: $DEPLOY_TARGET"
        if ! check_service_enhanced "$DEPLOY_TARGET Server" "$APP_CONTAINER" "$TARGET_PORT" "http://localhost/$DEPLOY_TARGET/health"; then
          overall_status=1
        fi
        
        # Check NGINX proxy with internal and external validation
        echo "ğŸŒ Checking NGINX Proxy"
        if ! check_service_enhanced "NGINX Proxy" "nginx-proxy" "" "http://localhost:80/health"; then
          echo "âš ï¸ NGINX proxy health check failed, but continuing..."
          # Note: Not failing overall status for NGINX as it might have different health endpoint behavior
        fi
        
        # Check API Server with internal-only validation (not exposed externally)
        echo "ğŸ”Œ Checking API Server (internal access only)"
        api_status=0
        if docker exec api-server sh -c "curl -sS -f --max-time 5 http://localhost:9000/health >/dev/null" 2>/dev/null; then
          echo "âœ… API Server: Internal health check passed"
        elif docker run --rm --network bluegreen-network curlimages/curl:latest -sS -f --max-time 5 "http://api-server:9000/health" >/dev/null 2>/dev/null; then
          echo "âœ… API Server: Network-level health check passed"
        else
          echo "âŒ API Server health check failed"
          api_status=1
        fi
        
        # Enhanced debugging information
        if [ $overall_status -ne 0 ] || [ $api_status -ne 0 ]; then
          echo "ğŸ” [DEBUG] System diagnostic information:"
          docker ps -a --format "table {{.Names}}\\t{{.Status}}\\t{{.Ports}}" | grep -E "(nginx|${DEPLOY_TARGET}|api)"
          echo "ğŸ” [DEBUG] Container health states:"
          for container in nginx-proxy "$APP_CONTAINER" api-server; do
            if docker ps --format "{{.Names}}" | grep -q "^$container\$"; then
              health_status=$(docker inspect --format="{{.State.Health.Status}}" "$container" 2>/dev/null || echo "no-healthcheck")
              running_status=$(docker inspect --format="{{.State.Running}}" "$container" 2>/dev/null || echo "unknown")
              echo "  $container: Running=$running_status, Health=$health_status"
            fi
          done
          
          echo "ğŸ” [DEBUG] Recent container logs:"
          docker logs --tail 10 "$APP_CONTAINER" 2>&1 | head -15 || echo "No logs for $APP_CONTAINER"
          docker logs --tail 10 nginx-proxy 2>&1 | head -15 || echo "No logs for nginx-proxy"
        fi
        
        # Final status evaluation
        if [ $overall_status -eq 0 ]; then
          if [ $api_status -eq 0 ]; then
            echo "ğŸ‰ All services are healthy - ready for traffic switch!"
          else
            echo "âš ï¸ Target environment is healthy but API server has issues - proceeding with caution"
          fi
        else
          echo "âŒ Health check failed - deployment cannot proceed"
          echo "ğŸ” Final container states:"
          docker ps -a --format "table {{.Names}}\\t{{.Status}}\\t{{.Ports}}"
          exit 1
        fi
      '

# 6. Zero-Downtime Test (Critical Validation).
zero-downtime-validation:
  stage: zero-downtime-test-dev
  image: alpine:latest
  <<: [*ssh_setup, *rules_dev_main]
  needs: ["health-check-inactive-environment"]
  script:
    - echo "ğŸ§ª Running zero-downtime deployment validation..."
    - |
      ssh "ubuntu@$DEPLOY_SERVER_DEV" '
        cd ~/bgTest/v5ToWindow
        echo "ğŸš€ Starting zero-downtime test before traffic switch..."
      
        # Quick availability test
        echo "ğŸ“Š Testing current service availability..."
        for i in $(seq 1 30); do
          if ! curl -f --max-time 2 "http://localhost:80/status" >/dev/null 2>&1; then
            echo "âŒ Service availability test failed"
            exit 1
          fi
          sleep 1
        done
      
        echo "âœ… Service is stable and ready for traffic switch"
      '

# 7. Switch Traffic (Manual Approval Required).
switch-traffic-to-inactive:
  stage: switch-traffic-dev
  image: alpine:latest
  <<: [*ssh_setup, *rules_dev_main]
  needs: ["zero-downtime-validation"]
  environment:
    name: production-dev
    url: "http://$DEPLOY_SERVER_DEV"
  when: manual
  allow_failure: false
  script:
    - echo "ğŸ”„ ZERO-DOWNTIME TRAFFIC SWITCH - Manual approval granted"
    - |
      ssh "ubuntu@$DEPLOY_SERVER_DEV" '
        cd ~/bgTest/v5ToWindow
        DEPLOY_TARGET=$(cat ~/deploy_target.env 2>/dev/null || echo "green")
        
        echo "ğŸš¦ Switching traffic to $DEPLOY_TARGET environment (True Blue-Green mode)..."
        
        # Debug: Check API server status first
        echo "ğŸ” Debugging API server status..."
        echo "ğŸ“Š Current container status:"
        docker ps --filter "name=api-server" --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
        
        echo "ğŸ” Testing API server connectivity..."
        api_health=$(docker run --rm --network bluegreen-network curlimages/curl:latest \
          curl -s --max-time 5 "http://api-server:9000/health" 2>/dev/null || echo "API_UNREACHABLE")
        echo "ğŸ“Š API health response: $api_health"
        
        # Execute traffic switch via API - using Docker internal network
        echo "ğŸ”„ Executing switch command..."
        switch_response=$(docker run --rm --network bluegreen-network curlimages/curl:latest \
          curl -s -X POST "http://api-server:9000/switch/$DEPLOY_TARGET" 2>/dev/null || echo "{\"success\":false,\"error\":\"network_call_failed\"}")
        
        echo "ğŸ“Š Raw switch response: $switch_response"
        
        if echo "$switch_response" | jq -e ".success" >/dev/null 2>&1; then
          echo "âœ… Traffic successfully switched to $DEPLOY_TARGET"
          echo "ğŸ“Š Switch details: $switch_response"
        else
          echo "âŒ Traffic switch failed: $switch_response"
          exit 1
        fi
        
        # Verify switch
        sleep 5
        if curl -f "http://localhost:80/status" >/dev/null 2>&1; then
          echo "âœ… Traffic switch verification successful"
        else
          echo "âŒ Traffic switch verification failed"
          exit 1
        fi
      '

# 8. Deployment Verification.
verify-deployment:
  stage: verify-deployment-dev
  image: alpine:latest
  <<: [*ssh_setup, *rules_dev_main]
  needs: ["switch-traffic-to-inactive"]
  script:
    - echo "ğŸ” Verifying zero-downtime deployment completion..."
    - |
      ssh "ubuntu@$DEPLOY_SERVER_DEV" '
        cd ~/bgTest/v5ToWindow
        
        echo "ğŸ“Š Post-deployment verification..."
        
        # Extended availability test
        failed_checks=0
        total_checks=50
        
        for i in $(seq 1 $total_checks); do
          if ! curl -f --max-time 3 "http://localhost:80/status" >/dev/null 2>&1; then
            failed_checks=$((failed_checks + 1))
          fi
          sleep 1
        done
        
        availability=$(echo "scale=2; (1 - $failed_checks/$total_checks) * 100" | bc -l || echo "100")
        
        echo "ğŸ“ˆ Deployment verification results:"
        echo "   - Total checks: $total_checks"
        echo "   - Failed checks: $failed_checks"
        echo "   - Availability: ${availability}%"
        
        if [ "$failed_checks" -eq 0 ]; then
          echo "ğŸ‰ ZERO-DOWNTIME DEPLOYMENT SUCCESSFUL!"
          echo "âœ… Perfect availability achieved: 100%"
        elif [ "$failed_checks" -le 2 ]; then
          echo "âš ï¸  Deployment completed with minor issues"
          echo "   Availability: ${availability}%"
        else
          echo "âŒ Deployment verification failed"
          echo "   Too many availability issues detected"
          exit 1
        fi
        
        # Clean up deployment lock after successful deployment
        rm -f deployment_state/deployment.lock 2>/dev/null || true
        echo "ğŸ”“ Deployment completed - lock cleaned up"
      '

# 9. Cleanup Previous Environment (Manual).
cleanup-previous-environment:
  stage: cleanup-dev
  image: alpine:latest
  <<: [*ssh_setup, *rules_dev_main]
  needs: ["verify-deployment"]
  when: manual
  allow_failure: true
  script:
    - echo "ğŸ§¹ Safe cleanup - graceful stop and remove previous environment..."
    - |
      ssh "ubuntu@$DEPLOY_SERVER_DEV" '
        cd ~/bgTest/v5ToWindow

        echo "ğŸ” Determine previous active environment..."
        PREVIOUS_ACTIVE=$(cat ~/current_active.env 2>/dev/null || echo "blue")
        echo "Previous active: $PREVIOUS_ACTIVE"

        # Safety check: If previous active equals deploy_target, then no-op
        DEPLOY_TARGET=$(cat ~/deploy_target.env 2>/dev/null || echo "green")
        if [ "$PREVIOUS_ACTIVE" = "$DEPLOY_TARGET" ]; then
          echo "â„¹ï¸  PREVIOUS_ACTIVE equals DEPLOY_TARGET; nothing to cleanup."
          exit 0
        fi

        APP_NAME="${PREVIOUS_ACTIVE}-app"
        echo "ğŸ§¹ Cleaning up previous app container: $APP_NAME"

        # 1) Find running containers that match the name filter
        RUNNING_IDS=$(docker ps --filter "name=$APP_NAME" -q || true)
        if [ -n "$RUNNING_IDS" ]; then
          echo "â³ Attempting graceful stop of running containers:"
          docker ps --filter "name=$APP_NAME" --format "{{.ID}}\t{{.Names}}\t{{.Status}}"
          # graceful stop with 30s timeout
          docker stop --time=30 $RUNNING_IDS || {
            echo "âš ï¸ Some containers failed to stop gracefully; attempting forced removal"
          }
        fi

        # 2) Remove any containers (running or exited) with this name
        ALL_IDS=$(docker ps -a --filter "name=$APP_NAME" -q || true)
        if [ -n "$ALL_IDS" ]; then
          echo "ğŸ—‘ï¸ Removing containers (including volumes):"
          docker ps -a --filter "name=$APP_NAME" --format "{{.ID}}\t{{.Names}}\t{{.Status}}"
          docker rm -v $ALL_IDS || {
            echo "âš ï¸ docker rm failed - please inspect"
          }
        else
          echo "â„¹ï¸ No containers found to remove for $APP_NAME"
        fi

        # 3) Prune dangling images
        echo "ğŸ” Pruning dangling images..."
        docker image prune -f --filter "dangling=true" || true

        echo "ğŸ‰ Previous environment cleanup finished."
        
        # Clean up deployment lock
        rm -f deployment_state/deployment.lock 2>/dev/null || true
        echo "ğŸ”“ Deployment lock cleaned up"
      '

# 10. Enhanced Emergency Rollback with Safety Checks (Manual)
emergency-rollback:
  stage: cleanup-dev
  image: alpine:latest
  <<: [*ssh_setup, *rules_dev_main]
  when: manual
  allow_failure: true
  environment:
    name: production-dev
    url: "http://$DEPLOY_SERVER_DEV"
  script:
    - echo "ğŸš¨ ENHANCED EMERGENCY ROLLBACK - Multi-Stage Safety Protocol"
    - |
      ssh "ubuntu@$DEPLOY_SERVER_DEV" '
        cd ~/bgTest/v5ToWindow
        
        echo "ğŸ” â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        echo "ğŸš¨ EMERGENCY ROLLBACK SAFETY PROTOCOL INITIATED"
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        
        # Stage 1: Pre-rollback validation
        echo "ğŸ” Stage 1: Pre-rollback System Assessment"
        
        # Determine rollback target
        PREVIOUS_ACTIVE=$(cat ~/current_active.env 2>/dev/null || echo "unknown")
        CURRENT_DEPLOY=$(cat ~/deploy_target.env 2>/dev/null || echo "unknown")
        DETECTION_CONFIDENCE=$(cat ~/detection_confidence.env 2>/dev/null || echo "low")
        
        if [ "$PREVIOUS_ACTIVE" = "unknown" ]; then
          echo "âŒ Cannot determine rollback target - no previous active environment recorded"
          echo "   Attempting fallback detection..."
          
          # Try to detect from current traffic
          CURRENT_TRAFFIC=$(docker run --rm --network bluegreen-network curlimages/curl:latest \
            curl -s --max-time 5 "http://api-server:9000/status" 2>/dev/null | jq -r ".current_deployment" 2>/dev/null || echo "")
          
          if [ -n "$CURRENT_TRAFFIC" ] && [ "$CURRENT_TRAFFIC" != "null" ]; then
            # If current traffic is going to the newly deployed target, rollback to the opposite
            if [ "$CURRENT_TRAFFIC" = "$CURRENT_DEPLOY" ]; then
              PREVIOUS_ACTIVE=$(if [ "$CURRENT_DEPLOY" = "blue" ]; then echo "green"; else echo "blue"; fi)
              echo "âš ï¸  Fallback detection: Rolling back to $PREVIOUS_ACTIVE (opposite of current $CURRENT_TRAFFIC)"
            else
              PREVIOUS_ACTIVE="$CURRENT_TRAFFIC"
              echo "âš ï¸  Fallback detection: Current traffic target is $PREVIOUS_ACTIVE"
            fi
          else
            echo "âŒ Critical Error: Cannot determine rollback target"
            echo "   Manual intervention required - please check system state"
            exit 1
          fi
        fi
        
        echo "ğŸ¯ Rollback target determined: $PREVIOUS_ACTIVE"
        echo "   Current deployment: $CURRENT_DEPLOY"
        echo "   Detection confidence: $DETECTION_CONFIDENCE"
        
        # Stage 2: Rollback target validation
        echo ""
        echo "ğŸ” Stage 2: Rollback Target Health Validation"
        
        ROLLBACK_CONTAINER="${PREVIOUS_ACTIVE}-app"
        ROLLBACK_PORT=$(if [ "$PREVIOUS_ACTIVE" = "blue" ]; then echo "3001"; else echo "3002"; fi)
        
        # Check if rollback target container exists and is healthy
        if docker ps --format "{{.Names}}" | grep -q "^$ROLLBACK_CONTAINER$"; then
          echo "âœ… Rollback target container exists: $ROLLBACK_CONTAINER"
          
          # Health check rollback target
          ROLLBACK_HEALTH=$(docker inspect --format='{{.State.Health.Status}}' "$ROLLBACK_CONTAINER" 2>/dev/null || echo "unhealthy")
          echo "   Health status: $ROLLBACK_HEALTH"
          
          if [ "$ROLLBACK_HEALTH" = "healthy" ]; then
            echo "âœ… Rollback target is healthy - safe to proceed"
          else
            echo "âš ï¸  Rollback target is not healthy - attempting basic connectivity test"
            if docker exec "$ROLLBACK_CONTAINER" curl -sS -f --max-time 3 "http://localhost:$ROLLBACK_PORT/health" >/dev/null 2>&1; then
              echo "âœ… Basic connectivity test passed - proceeding with caution"
            else
              echo "âŒ Rollback target is not responding"
              echo "   This rollback may not restore service!"
              echo "   Consider manual intervention instead"
              read -t 10 -p "Continue anyway? (y/N): " confirmation || confirmation="N"
              if [ "$confirmation" != "y" ] && [ "$confirmation" != "Y" ]; then
                echo "   Rollback aborted for safety"
                exit 1
              fi
            fi
          fi
        else
          echo "âŒ Critical Error: Rollback target container not found: $ROLLBACK_CONTAINER"
          echo "   Available containers:"
          docker ps --format "   {{.Names}}\t{{.Status}}"
          exit 1
        fi
        
        # Stage 3: Current system state backup
        echo ""
        echo "ğŸ” Stage 3: System State Backup"
        
        # Backup current configuration
        mkdir -p ~/rollback_backup/$(date +%Y%m%d_%H%M%S)
        BACKUP_DIR="~/rollback_backup/$(date +%Y%m%d_%H%M%S)"
        
        docker exec nginx-proxy cat /etc/nginx/conf.d/active.env > "$BACKUP_DIR/active.env.backup" 2>/dev/null || echo "" > "$BACKUP_DIR/active.env.backup"
        echo "$(date): Rollback from $CURRENT_DEPLOY to $PREVIOUS_ACTIVE" > "$BACKUP_DIR/rollback.log"
        
        echo "ğŸ’¾ Configuration backed up to $BACKUP_DIR"
        
        # Stage 4: Execute rollback
        echo ""
        echo "ğŸ” Stage 4: Executing Safe Rollback"
        
        echo "   â†’ Switching traffic from $CURRENT_DEPLOY to $PREVIOUS_ACTIVE..."
        
        # Execute rollback via API with retry mechanism
        ROLLBACK_ATTEMPTS=3
        ROLLBACK_SUCCESS=false
        
        for attempt in $(seq 1 $ROLLBACK_ATTEMPTS); do
          echo "   Rollback attempt $attempt/$ROLLBACK_ATTEMPTS..."
          
          rollback_response=$(docker run --rm --network bluegreen-network curlimages/curl:latest \
            curl -s -X POST "http://api-server:9000/switch/$PREVIOUS_ACTIVE" 2>/dev/null || echo "{\"success\":false,\"error\":\"network_error\"}")
          
          if echo "$rollback_response" | jq -e ".success" >/dev/null 2>&1; then
            echo "âœ… Rollback API call successful (attempt $attempt)"
            ROLLBACK_SUCCESS=true
            break
          else
            echo "âŒ Rollback attempt $attempt failed: $rollback_response"
            [ $attempt -lt $ROLLBACK_ATTEMPTS ] && sleep 3
          fi
        done
        
        if [ "$ROLLBACK_SUCCESS" = "false" ]; then
          echo "âŒ All rollback attempts failed - trying manual nginx configuration"
          
          # Manual nginx configuration as last resort
          echo "set \$active \"$PREVIOUS_ACTIVE\";" | docker exec -i nginx-proxy tee /etc/nginx/conf.d/active.env > /dev/null
          docker exec nginx-proxy nginx -s reload
          
          if [ $? -eq 0 ]; then
            echo "âœ… Manual nginx rollback completed"
            ROLLBACK_SUCCESS=true
          else
            echo "âŒ Manual nginx rollback failed - critical error"
          fi
        fi
        
        # Stage 5: Rollback verification
        echo ""
        echo "ğŸ” Stage 5: Rollback Verification"
        
        if [ "$ROLLBACK_SUCCESS" = "true" ]; then
          # Multi-layer verification
          VERIFICATION_PASSED=0
          
          # Test 1: Basic connectivity
          for i in $(seq 1 5); do
            if curl -f --max-time 3 "http://localhost:80/status" >/dev/null 2>&1; then
              VERIFICATION_PASSED=$((VERIFICATION_PASSED + 1))
            fi
            sleep 1
          done
          
          # Test 2: Version verification
          CURRENT_VERSION=$(curl -s --max-time 3 "http://localhost:80/version" 2>/dev/null | jq -r ".version" 2>/dev/null || echo "unknown")
          echo "   Current version after rollback: $CURRENT_VERSION"
          
          if [ $VERIFICATION_PASSED -ge 4 ]; then  # At least 4/5 tests must pass
            echo "âœ… ğŸ† EMERGENCY ROLLBACK SUCCESSFUL! ğŸ†"
            echo "   Traffic restored to $PREVIOUS_ACTIVE environment"
            echo "   Verification: $VERIFICATION_PASSED/5 tests passed"
            echo "   System version: $CURRENT_VERSION"
          else
            echo "âŒ ğŸš¨ ROLLBACK VERIFICATION FAILED! ğŸš¨"
            echo "   Only $VERIFICATION_PASSED/5 verification tests passed"
            echo "   Service may still be impaired - manual intervention required"
          fi
        else
          echo "âŒ ğŸš¨ EMERGENCY ROLLBACK FAILED! ğŸš¨"
          echo "   Manual intervention urgently required"
          exit 1
        fi
        
        echo ""
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        echo "ğŸ† EMERGENCY ROLLBACK PROTOCOL COMPLETED"
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
      '