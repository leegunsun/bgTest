---
# True Blue-Green Deployment CI/CD Pipeline
# Implements zero-downtime deployment with separated container architecture

default:
  tags:
    #    - mac-mini
    - home-runner

stages:
  - build-dev
  - test-dev
  - detect-env-dev
  - deploy-inactive-dev
  - health-check-dev
  - zero-downtime-test-dev
  - switch-traffic-dev
  - verify-deployment-dev
  - cleanup-dev

# Common variables
variables:
  GIT_DEPTH: "0"
#  CI_DEBUG_TRACE: "true"  # ÏÉÅÏÑ∏ ÎîîÎ≤ÑÍ∑∏ Î°úÍ∑∏ ÌôúÏÑ±Ìôî
  NODE_OPTIONS: "--max_old_space_size=2048"
  DOCKER_DRIVER: overlay2
  COMPOSE_FILE: "docker-compose.yml"
  # Dynamic versioning support
  BLUE_VERSION: "${CI_COMMIT_TAG:-${CI_COMMIT_SHORT_SHA}}"
  GREEN_VERSION: "${CI_COMMIT_TAG:-${CI_COMMIT_SHORT_SHA}}"
  DEPLOYMENT_VERSION: "${CI_COMMIT_TAG:-${CI_COMMIT_SHORT_SHA}}"
  
  # Blue-Green Cleanup Configuration
  CLEANUP_STRATEGY: "aggressive"    # Options: aggressive, balanced, conservative
  KEEP_INACTIVE_MINUTES: "5"       # Minutes to keep inactive environment for rollback safety

# Reusable rules
.rules_dev_and_main: &rules_dev_main
  rules:
    - if: '$CI_COMMIT_BRANCH == "dev"'
    - if: '$CI_COMMIT_BRANCH == "main"'
    - when: never

# Reusable SSH setup
.ssh_setup: &ssh_setup
  before_script:
    - apk add --no-cache bash openssh-client curl jq docker docker-compose
    - eval $(ssh-agent -s)
    - echo "üîç Validating CI/CD Variables..."
    - |
      if [ -z "$AWS_PEM_DEV" ] || [ -z "$DEPLOY_SERVER_DEV" ]; then
        echo "‚ùå ERROR: Required CI/CD variables not configured"
        echo "Required: AWS_PEM_DEV (File), DEPLOY_SERVER_DEV (Variable)"
        exit 1
      fi
    - chmod 600 "$AWS_PEM_DEV"
    - ssh-add "$AWS_PEM_DEV"
    - mkdir -p ~/.ssh
    - echo -e "Host *\n\tStrictHostKeyChecking no\n" > ~/.ssh/config
    - echo "‚úÖ SSH setup completed"

# 1. Build Stage
build-dev:
  stage: build-dev
  image: node:18-alpine
  <<: *rules_dev_main
  script:
    - echo "üèóÔ∏è  Building Blue-Green unified architecture with version ${DEPLOYMENT_VERSION}..."
    - cp "$DEV_ENV_FILE" ./.env || echo "No env file configured"
    - echo "VERSION=${DEPLOYMENT_VERSION}" >> ./.env
    - echo "üì¶ Preparing artifacts for unified container deployment..."
    - echo "üîß Version configuration:"
    - echo "   BLUE_VERSION=${BLUE_VERSION}"
    - echo "   GREEN_VERSION=${GREEN_VERSION}"
    - echo "   DEPLOYMENT_VERSION=${DEPLOYMENT_VERSION}"
    - ls -la app-service/ api-service/ monitoring/ app-server/ || echo "Service directories ready"
  artifacts:
    expire_in: 3 days
    paths:
      - ./app-service/
      - ./api-service/
      - ./monitoring/
      - ./scripts/
      - ./app-server/
      - ./nginx.conf
      - ./conf.d/
      - ./admin.html
      - ./docker-compose.yml
      - ./.env

# 2. Test Stage
test-dev:
  stage: test-dev
  image: node:18-alpine
  <<: *rules_dev_main
  needs: ["build-dev"]
  script:
    - echo "üß™ Testing unified services architecture (True Blue-Green Pattern)..."
    - node -c app-server/app.js
    - node -c api-server/app.js
    - echo "‚úÖ All service syntax checks passed - Single codebase architecture"

# 3. Environment Detection
detect-active-environment:
  stage: detect-env-dev
  image: alpine:latest
  <<: [*ssh_setup, *rules_dev_main]
  needs: ["build-dev", "test-dev"]
  script:
#    - set -x  # Î™®Îì† Î™ÖÎ†πÏñ¥ Ï∂úÎ†•
    - echo "üîç Detecting current active environment..."
    - |
      ssh "ubuntu@$DEPLOY_SERVER_DEV" '
        cd ~/bgTest/v5ToWindow
        echo "üìä Environment Detection:"
        
        # Enhanced environment detection with API fallback
        echo "üîç Detecting current environment with multiple methods..."
        
        if docker ps --filter "name=nginx-proxy" --format "table {{.Names}}" | grep -q nginx-proxy; then
          echo "‚úÖ Blue-Green system is running"
          
          # Try API-based detection first (more reliable) - using Docker internal network
          API_RESPONSE=$(docker run --rm --network bluegreen-network curlimages/curl:latest \
            curl -s --max-time 5 "http://api-server:9000/status" 2>/dev/null || echo "")
          API_ACTIVE=$(echo "$API_RESPONSE" | jq -r ".current_deployment" 2>/dev/null || echo "")
          
          # Fallback to file-based detection
          FILE_ACTIVE=$(docker exec nginx-proxy cat /etc/nginx/conf.d/active.env | grep -o "blue\|green" 2>/dev/null || echo "")
          
          # Choose the most reliable source
          if [ -n "$API_ACTIVE" ] && [ "$API_ACTIVE" != "null" ]; then
            CURRENT_ACTIVE="$API_ACTIVE"
            echo "üìä Using API-detected environment: $CURRENT_ACTIVE"
          elif [ -n "$FILE_ACTIVE" ]; then
            CURRENT_ACTIVE="$FILE_ACTIVE"
            echo "üìÑ Using file-detected environment: $CURRENT_ACTIVE"
          else
            CURRENT_ACTIVE="blue"
            echo "‚ö†Ô∏è  No reliable detection, defaulting to: $CURRENT_ACTIVE"
          fi
          
          # True Blue-Green deployment: Deploy to inactive environment
          if [ "$CURRENT_ACTIVE" = "blue" ]; then
            DEPLOY_TARGET="green"
            echo "üîµ‚Üíüü¢ Current: blue, Deploying to: green"
          else
            DEPLOY_TARGET="blue"
            echo "üü¢‚Üíüîµ Current: green, Deploying to: blue"
          fi
        else
          echo "‚ö†Ô∏è  System not running, defaulting to green deployment"
          CURRENT_ACTIVE="blue"
          DEPLOY_TARGET="green"
        fi
        
        echo "Current active: $CURRENT_ACTIVE"
        echo "Deploy target: $DEPLOY_TARGET"
        
        # Save environment info
        echo "$CURRENT_ACTIVE" > ~/current_active.env
        echo "$DEPLOY_TARGET" > ~/deploy_target.env
      '

# 4. Deploy to Inactive Environment ONLY (ZERO DOWNTIME)
deploy-to-inactive-environment:
  stage: deploy-inactive-dev
  image: alpine:latest
  <<: [*ssh_setup, *rules_dev_main]
  needs: ["detect-active-environment"]
  environment:
    name: inactive-env
    url: "http://$DEPLOY_SERVER_DEV"
  script:
    - echo "üöÄ TRUE BLUE-GREEN DEPLOYMENT - Deploy to inactive environment only"
    - echo "üìÅ Transferring unified service architecture..."
    - ssh "ubuntu@$DEPLOY_SERVER_DEV" "mkdir -p ~/bgTest/v5ToWindow"
    - scp -r ./app-service/ "ubuntu@$DEPLOY_SERVER_DEV:~/bgTest/v5ToWindow/"
    - scp -r ./api-service/ "ubuntu@$DEPLOY_SERVER_DEV:~/bgTest/v5ToWindow/"
    - scp -r ./api-server/ "ubuntu@$DEPLOY_SERVER_DEV:~/bgTest/v5ToWindow/"
    - scp -r ./monitoring/ "ubuntu@$DEPLOY_SERVER_DEV:~/bgTest/v5ToWindow/"
    - scp -r ./app-server/ "ubuntu@$DEPLOY_SERVER_DEV:~/bgTest/v5ToWindow/"
    - ssh "ubuntu@$DEPLOY_SERVER_DEV" "mkdir -p ~/bgTest/v5ToWindow/conf.d"
    - scp ./conf.d/upstreams.conf "ubuntu@$DEPLOY_SERVER_DEV:~/bgTest/v5ToWindow/conf.d/"
    - scp ./conf.d/routing.conf "ubuntu@$DEPLOY_SERVER_DEV:~/bgTest/v5ToWindow/conf.d/"
    - scp ./docker-compose.yml "ubuntu@$DEPLOY_SERVER_DEV:~/bgTest/v5ToWindow/"
    - scp ./nginx.conf "ubuntu@$DEPLOY_SERVER_DEV:~/bgTest/v5ToWindow/"
    - scp ./admin.html "ubuntu@$DEPLOY_SERVER_DEV:~/bgTest/v5ToWindow/"
    - scp ./.env "ubuntu@$DEPLOY_SERVER_DEV:~/bgTest/v5ToWindow/" || echo "No .env file found, using defaults"
    - echo "üê≥ Deploying ONLY to inactive environment (maintaining zero downtime)..."
    - |
      ssh "ubuntu@$DEPLOY_SERVER_DEV" '
        cd ~/bgTest/v5ToWindow
        
        # True Blue-Green deployment: Deploy to inactive environment
        DEPLOY_TARGET=$(cat ~/deploy_target.env 2>/dev/null || echo "green")
        DEPLOY_VERSION="'${DEPLOYMENT_VERSION}'"
        echo "üéØ Deploying version $DEPLOY_VERSION to $DEPLOY_TARGET environment (True Blue-Green mode)"
        
        # Set version for target environment (True Blue-Green mode)
        if [ "$DEPLOY_TARGET" = "blue" ]; then
          export BLUE_VERSION="$DEPLOY_VERSION"
          echo "BLUE_VERSION=$DEPLOY_VERSION" >> .env
          echo "üîµ True Blue-Green: Setting BLUE_VERSION=$DEPLOY_VERSION"
        else
          export GREEN_VERSION="$DEPLOY_VERSION"
          echo "GREEN_VERSION=$DEPLOY_VERSION" >> .env
          echo "üü¢ True Blue-Green: Setting GREEN_VERSION=$DEPLOY_VERSION"
        fi
        
        # Ensure deployment metadata directory exists
        mkdir -p deployment_state
        
        # Install Docker if needed
        if ! command -v docker &> /dev/null; then
          echo "üì¶ Installing Docker..."
          curl -fsSL https://get.docker.com -o get-docker.sh
          sudo sh get-docker.sh
          sudo usermod -aG docker ubuntu
          sudo systemctl start docker
          sudo systemctl enable docker
        fi
        
        # Ensure Docker permissions and restart if needed
        sudo usermod -aG docker ubuntu
        sudo systemctl restart docker
        sudo chmod 666 /var/run/docker.sock || true
        newgrp docker || true
        
        # Install debugging tools
        sudo apt-get update -qq >/dev/null 2>&1 || true
        sudo apt-get install -y netcat-openbsd net-tools >/dev/null 2>&1 || true
        
        # Install Docker Compose if needed
        if ! command -v docker-compose &> /dev/null; then
          echo "üì¶ Installing Docker Compose..."
          sudo curl -L "https://github.com/docker/compose/releases/download/v2.24.0/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
          sudo chmod +x /usr/local/bin/docker-compose
          sudo ln -sf /usr/local/bin/docker-compose /usr/bin/docker-compose
        fi
        
        # Verify Docker is accessible
        echo "üîç Verifying Docker access..."
        if ! docker ps >/dev/null 2>&1 && ! sudo docker ps >/dev/null 2>&1; then
          echo "‚ùå Docker is not accessible. Please check Docker installation and permissions."
          exit 1
        fi
        
        # Check if system is already running
        if docker ps --filter "name=nginx-proxy" --format "table {{.Names}}" | grep -q nginx-proxy; then
          echo "‚úÖ System is running - deploying to inactive $DEPLOY_TARGET environment"
          
          # TRUE ZERO-DOWNTIME DEPLOYMENT - NO CONTAINER STOP/KILL
          echo "üîÑ Zero-downtime deployment to $DEPLOY_TARGET environment..."
          
          # Rebuild API server with latest fixes (network access issue resolution)
          echo "üîß Rebuilding API server with network access fixes..."
          docker-compose -f docker-compose.yml build api-server || sudo docker-compose -f docker-compose.yml build api-server
          docker-compose -f docker-compose.yml up -d --no-deps --force-recreate api-server || sudo docker-compose -f docker-compose.yml up -d --no-deps --force-recreate api-server
          
          # Rebuild target application environment
          echo "üéØ Rebuilding $DEPLOY_TARGET application environment..."
          docker-compose -f docker-compose.yml build ${DEPLOY_TARGET}-app || sudo docker-compose -f docker-compose.yml build ${DEPLOY_TARGET}-app
          docker-compose -f docker-compose.yml up -d --no-deps --force-recreate ${DEPLOY_TARGET}-app || sudo docker-compose -f docker-compose.yml up -d --no-deps --force-recreate ${DEPLOY_TARGET}-app
          
          echo "‚è≥ Waiting for API server and $DEPLOY_TARGET environment to be ready..."
          sleep 45  # Extended wait time for API server + target environment startup
          
          # Verify API server is accessible with new implementation
          echo "üîç Verifying API server accessibility..."
          for attempt in $(seq 1 10); do
            if docker run --rm --network bluegreen-network curlimages/curl:latest curl -s --max-time 3 "http://api-server:9000/health" >/dev/null; then
              echo "‚úÖ API server is responsive (attempt $attempt/10)"
              break
            else
              echo "‚è≥ API server not ready yet (attempt $attempt/10)..."
              sleep 5
            fi
            if [ $attempt -eq 10 ]; then
              echo "‚ùå API server failed to become ready after 10 attempts"
              echo "üîç Container status:"
              docker ps --filter "name=api-server"
              echo "üîç API server logs:"
              docker logs api-server --tail 50 || true
              exit 1
            fi
          done
          
        else
          echo "üèóÔ∏è  Initial system deployment - starting all services"
          
          # Initialize active.env for first deployment (True Blue-Green setup)
          if [ ! -f "conf.d/active.env" ]; then
            echo "üîß Initializing active.env for first deployment..."
            echo "set \$active \"green\";" > conf.d/active.env
            echo "‚úÖ Created initial active.env with green environment"
          else
            echo "‚ÑπÔ∏è  active.env already exists, preserving current configuration"
          fi
          
          docker-compose -f docker-compose.yml down --timeout 10 || sudo docker-compose -f docker-compose.yml down --timeout 10 || true
          docker-compose -f docker-compose.yml build || sudo docker-compose -f docker-compose.yml build
          docker-compose -f docker-compose.yml up -d || sudo docker-compose -f docker-compose.yml up -d
          
          echo "‚è≥ Waiting for all services to be ready (t2.micro needs more time)..."
          sleep 120
          
          # ÏÉÅÏÑ∏ ÎîîÎ≤ÑÍπÖ Ï†ïÎ≥¥ ÏàòÏßë
          echo "üîç [DEBUG] Container status check:"
          docker ps -a --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
          
          echo "üîç [DEBUG] Network information:"
          docker network ls
          docker network inspect bluegreen-network | jq ".[0].Containers" || true
          
          echo "üîç [DEBUG] System resource usage:"
          free -h || true
          df -h || true
        fi
        
        # Enhanced Docker-native health checking with internal network validation
        echo "üè• Health checking deployed $DEPLOY_TARGET environment with Docker-native methods..."
        TARGET_PORT=$(if [ "$DEPLOY_TARGET" = "blue" ]; then echo "3001"; else echo "3002"; fi)
        APP_CONTAINER="${DEPLOY_TARGET}-app"
        
        # Helper function: Get Docker health status
        get_docker_health_status() {
          if docker inspect --format='{{json .State.Health}}' "$1" >/dev/null 2>&1; then
            docker inspect --format='{{.State.Health.Status}}' "$1" 2>/dev/null || echo "no-health"
          else
            echo "no-health"
          fi
        }
        
        # Helper function: Internal container health check
        app_internal_health_check() {
          docker exec "$APP_CONTAINER" sh -c "curl -sS -f --max-time 5 http://localhost:$TARGET_PORT/health >/dev/null" 2>/dev/null
          return $?
        }
        
        # Helper function: Network-level health check via ephemeral container
        network_health_check() {
          docker run --rm --network bluegreen-network curlimages/curl:latest \
            -sS -f --max-time 5 "http://${APP_CONTAINER}:${TARGET_PORT}/health" >/dev/null 2>/dev/null
          return $?
        }
        
        # Enhanced health check loop with exponential backoff
        for attempt in $(seq 1 40); do
          echo "üîç Health check attempt $attempt/40 for $DEPLOY_TARGET (container: $APP_CONTAINER)"
          
          # Priority 1: Check Docker-managed health status
          HEALTH_STATUS=$(get_docker_health_status "$APP_CONTAINER")
          echo "üîé Docker Health Status: $HEALTH_STATUS"
          
          if [ "$HEALTH_STATUS" = "healthy" ]; then
            echo "‚úÖ Docker-level health = healthy"
            
            # Version verification via internal network
            DEPLOYED_VERSION=$(docker exec "$APP_CONTAINER" sh -c "curl -s --max-time 3 http://localhost:$TARGET_PORT/version 2>/dev/null | jq -r .version 2>/dev/null" || echo "unknown")
            if [ "$DEPLOYED_VERSION" != "unknown" ]; then
              echo "üìã Deployed version: $DEPLOYED_VERSION"
              DEPLOYMENT_ID=$(docker exec "$APP_CONTAINER" sh -c "curl -s --max-time 3 http://localhost:$TARGET_PORT/version 2>/dev/null | jq -r .deployment_id 2>/dev/null" || echo "unknown")
              echo "üÜî Deployment ID: $DEPLOYMENT_ID"
            fi
            break
          fi
          
          # Priority 2: Internal container health check
          echo "üîç Trying internal container health check (docker exec)..."
          if app_internal_health_check; then
            echo "‚úÖ Internal container health check passed"
            
            # Version verification
            DEPLOYED_VERSION=$(docker exec "$APP_CONTAINER" sh -c "curl -s --max-time 3 http://localhost:$TARGET_PORT/version 2>/dev/null | jq -r .version 2>/dev/null" || echo "unknown")
            echo "üìã Deployed version: $DEPLOYED_VERSION"
            break
          fi
          
          # Priority 3: Network-level health check via Docker network
          echo "üîç Trying network-level health check (ephemeral curl container)..."
          if network_health_check; then
            echo "‚úÖ Network-level health check passed"
            break
          fi
          
          # Enhanced debugging at key intervals
          if [ $attempt -eq 3 ] || [ $attempt -eq 10 ] || [ $attempt -eq 20 ] || [ $attempt -eq 35 ]; then
            echo "üîç [DEBUG] Container status (attempt $attempt):"
            docker ps -a --format "table {{.Names}}\\t{{.Status}}\\t{{.Ports}}" | grep -E "(nginx|${DEPLOY_TARGET}|api)" || true
            echo "üîç [DEBUG] Container logs (last 15 lines):"
            docker logs --tail 15 "$APP_CONTAINER" 2>&1 | head -20 || echo "‚ùå No logs for $APP_CONTAINER"
            echo "üîç [DEBUG] Container inspect state:"
            docker inspect --format='{{json .State}}' "$APP_CONTAINER" | jq '.Running, .Health.Status, .RestartCount, .ExitCode' 2>/dev/null || echo "‚ùå Inspect failed"
            echo "üîç [DEBUG] Network connectivity test:"
            docker exec "$APP_CONTAINER" sh -c "netstat -tulpn 2>/dev/null | grep :$TARGET_PORT || echo 'Port not bound inside container'"
          fi
          
          # Final attempt failure handling
          if [ $attempt -eq 40 ]; then
            echo "‚ùå $DEPLOY_TARGET environment failed to become healthy after $attempt attempts"
            echo "üîç [FINAL DEBUG] Complete diagnostic information:"
            docker ps -a --format "table {{.Names}}\\t{{.Status}}\\t{{.Ports}}"
            echo "üìã Final container logs:"
            docker logs --tail 50 "$APP_CONTAINER" 2>&1 || echo "No $APP_CONTAINER logs"
            docker logs --tail 20 api-server 2>&1 || echo "No api-server logs"  
            docker logs --tail 20 nginx-proxy 2>&1 || echo "No nginx-proxy logs"
            echo "üîç Final network and process state:"
            docker exec "$APP_CONTAINER" sh -c "ps aux; echo '---'; netstat -tulpn" 2>/dev/null || echo "Cannot access container internals"
            exit 1
          fi
          
          # Exponential backoff: progressively increase wait time
          sleep_duration=$(( 3 + attempt * 2 ))
          if [ $sleep_duration -gt 30 ]; then sleep_duration=30; fi
          echo "‚è≥ Waiting ${sleep_duration}s before next attempt (progressive backoff)..."
          sleep "$sleep_duration"
        done
        
        echo "üéâ Inactive environment deployment completed successfully with version tracking!"
      '

# 5. Health Check Inactive Environment
health-check-inactive-environment:
  stage: health-check-dev
  image: alpine:latest
  <<: [*ssh_setup, *rules_dev_main]
  needs: ["deploy-to-inactive-environment"]
  retry: 2
  script:
    - echo "üè• Comprehensive Docker-native health check of inactive environment..."
    - |
      ssh "ubuntu@$DEPLOY_SERVER_DEV" '
        cd ~/bgTest/v5ToWindow
        DEPLOY_TARGET=$(cat ~/deploy_target.env 2>/dev/null || echo "green")
        echo "üéØ Health checking $DEPLOY_TARGET environment using Docker-native methods..."
        
        APP_CONTAINER="${DEPLOY_TARGET}-app"
        TARGET_PORT=$(if [ "$DEPLOY_TARGET" = "blue" ]; then echo "3001"; else echo "3002"; fi)
        
        # Enhanced service health check with multiple validation layers
        check_service_enhanced() {
          local service_name="$1"
          local container_name="$2"
          local internal_port="$3"
          local proxy_url="$4"
          local max_attempts=12
          
          echo "üîç Enhanced health check for $service_name (container: $container_name)..."
          
          for attempt in $(seq 1 $max_attempts); do
            echo "üîç Attempt $attempt/$max_attempts for $service_name"
            
            # Method 1: Docker health status (if available)
            if docker inspect --format="{{.State.Health.Status}}" "$container_name" 2>/dev/null | grep -q "healthy"; then
              echo "‚úÖ $service_name: Docker health status = healthy"
              return 0
            fi
            
            # Method 2: Internal container health check
            if [ -n "$internal_port" ] && docker exec "$container_name" sh -c "curl -sS -f --max-time 3 http://localhost:$internal_port/health >/dev/null" 2>/dev/null; then
              echo "‚úÖ $service_name: Internal health check passed"
              return 0
            fi
            
            # Method 3: Network-level health check via ephemeral container
            if docker run --rm --network bluegreen-network curlimages/curl:latest -sS -f --max-time 3 "http://$container_name:$internal_port/health" >/dev/null 2>/dev/null; then
              echo "‚úÖ $service_name: Network-level health check passed"
              return 0
            fi
            
            # Method 4: Proxy-based health check (fallback for NGINX routing validation)
            if [ -n "$proxy_url" ] && curl -sS -f --max-time 3 "$proxy_url" >/dev/null 2>/dev/null; then
              echo "‚úÖ $service_name: Proxy-based health check passed"
              return 0
            fi
            
            # Progressive wait with exponential backoff
            wait_time=$(( 2 + attempt ))
            if [ $wait_time -gt 15 ]; then wait_time=15; fi
            echo "‚è≥ $service_name not ready, waiting ${wait_time}s... ($attempt/$max_attempts)"
            sleep "$wait_time"
          done
          
          echo "‚ùå $service_name health check failed after $max_attempts attempts"
          return 1
        }
        
        # Check core services with enhanced validation
        overall_status=0
        
        # Check target environment (blue or green) with comprehensive validation
        echo "üéØ Checking target environment: $DEPLOY_TARGET"
        if ! check_service_enhanced "$DEPLOY_TARGET Server" "$APP_CONTAINER" "$TARGET_PORT" "http://localhost/$DEPLOY_TARGET/health"; then
          overall_status=1
        fi
        
        # Check NGINX proxy with internal and external validation
        echo "üåê Checking NGINX Proxy"
        if ! check_service_enhanced "NGINX Proxy" "nginx-proxy" "" "http://localhost:80/health"; then
          echo "‚ö†Ô∏è NGINX proxy health check failed, but continuing..."
          # Note: Not failing overall status for NGINX as it might have different health endpoint behavior
        fi
        
        # Check API Server with internal-only validation (not exposed externally)
        echo "üîå Checking API Server (internal access only)"
        api_status=0
        if docker exec api-server sh -c "curl -sS -f --max-time 5 http://localhost:9000/health >/dev/null" 2>/dev/null; then
          echo "‚úÖ API Server: Internal health check passed"
        elif docker run --rm --network bluegreen-network curlimages/curl:latest -sS -f --max-time 5 "http://api-server:9000/health" >/dev/null 2>/dev/null; then
          echo "‚úÖ API Server: Network-level health check passed"
        else
          echo "‚ùå API Server health check failed"
          api_status=1
        fi
        
        # Enhanced debugging information
        if [ $overall_status -ne 0 ] || [ $api_status -ne 0 ]; then
          echo "üîç [DEBUG] System diagnostic information:"
          docker ps -a --format "table {{.Names}}\\t{{.Status}}\\t{{.Ports}}" | grep -E "(nginx|${DEPLOY_TARGET}|api)"
          echo "üîç [DEBUG] Container health states:"
          for container in nginx-proxy "$APP_CONTAINER" api-server; do
            if docker ps --format "{{.Names}}" | grep -q "^$container\$"; then
              health_status=$(docker inspect --format="{{.State.Health.Status}}" "$container" 2>/dev/null || echo "no-healthcheck")
              running_status=$(docker inspect --format="{{.State.Running}}" "$container" 2>/dev/null || echo "unknown")
              echo "  $container: Running=$running_status, Health=$health_status"
            fi
          done
          
          echo "üîç [DEBUG] Recent container logs:"
          docker logs --tail 10 "$APP_CONTAINER" 2>&1 | head -15 || echo "No logs for $APP_CONTAINER"
          docker logs --tail 10 nginx-proxy 2>&1 | head -15 || echo "No logs for nginx-proxy"
        fi
        
        # Final status evaluation
        if [ $overall_status -eq 0 ]; then
          if [ $api_status -eq 0 ]; then
            echo "üéâ All services are healthy - ready for traffic switch!"
          else
            echo "‚ö†Ô∏è Target environment is healthy but API server has issues - proceeding with caution"
          fi
        else
          echo "‚ùå Health check failed - deployment cannot proceed"
          echo "üîç Final container states:"
          docker ps -a --format "table {{.Names}}\\t{{.Status}}\\t{{.Ports}}"
          exit 1
        fi
      '

# 6. Zero-Downtime Test (Critical Validation).
zero-downtime-validation:
  stage: zero-downtime-test-dev
  image: alpine:latest
  <<: [*ssh_setup, *rules_dev_main]
  needs: ["health-check-inactive-environment"]
  script:
    - echo "üß™ Running zero-downtime deployment validation..."
    - |
      ssh "ubuntu@$DEPLOY_SERVER_DEV" '
        cd ~/bgTest/v5ToWindow
        echo "üöÄ Starting zero-downtime test before traffic switch..."
      
        # Quick availability test
        echo "üìä Testing current service availability..."
        for i in $(seq 1 30); do
          if ! curl -f --max-time 2 "http://localhost:80/status" >/dev/null 2>&1; then
            echo "‚ùå Service availability test failed"
            exit 1
          fi
          sleep 1
        done
      
        echo "‚úÖ Service is stable and ready for traffic switch"
      '

# 7. Switch Traffic (Manual Approval Required).
switch-traffic-to-inactive:
  stage: switch-traffic-dev
  image: alpine:latest
  <<: [*ssh_setup, *rules_dev_main]
  needs: ["zero-downtime-validation"]
  environment:
    name: production-dev
    url: "http://$DEPLOY_SERVER_DEV"
  when: manual
  allow_failure: false
  script:
    - echo "üîÑ ZERO-DOWNTIME TRAFFIC SWITCH - Manual approval granted"
    - |
      ssh "ubuntu@$DEPLOY_SERVER_DEV" '
        cd ~/bgTest/v5ToWindow
        DEPLOY_TARGET=$(cat ~/deploy_target.env 2>/dev/null || echo "green")
        
        echo "üö¶ Switching traffic to $DEPLOY_TARGET environment (True Blue-Green mode)..."
        
        # Debug: Check API server status first
        echo "üîç Debugging API server status..."
        echo "üìä Current container status:"
        docker ps --filter "name=api-server" --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
        
        echo "üîç Testing API server connectivity..."
        api_health=$(docker run --rm --network bluegreen-network curlimages/curl:latest \
          curl -s --max-time 5 "http://api-server:9000/health" 2>/dev/null || echo "API_UNREACHABLE")
        echo "üìä API health response: $api_health"
        
        # Execute traffic switch via API - using Docker internal network
        echo "üîÑ Executing switch command..."
        switch_response=$(docker run --rm --network bluegreen-network curlimages/curl:latest \
          curl -s -X POST "http://api-server:9000/switch/$DEPLOY_TARGET" 2>/dev/null || echo "{\"success\":false,\"error\":\"network_call_failed\"}")
        
        echo "üìä Raw switch response: $switch_response"
        
        if echo "$switch_response" | jq -e ".success" >/dev/null 2>&1; then
          echo "‚úÖ Traffic successfully switched to $DEPLOY_TARGET"
          echo "üìä Switch details: $switch_response"
        else
          echo "‚ùå Traffic switch failed: $switch_response"
          exit 1
        fi
        
        # Verify switch
        sleep 5
        if curl -f "http://localhost:80/status" >/dev/null 2>&1; then
          echo "‚úÖ Traffic switch verification successful"
        else
          echo "‚ùå Traffic switch verification failed"
          exit 1
        fi
      '

# 8. Deployment Verification.
verify-deployment:
  stage: verify-deployment-dev
  image: alpine:latest
  <<: [*ssh_setup, *rules_dev_main]
  needs: ["switch-traffic-to-inactive"]
  script:
    - echo "üîç Verifying zero-downtime deployment completion..."
    - |
      ssh "ubuntu@$DEPLOY_SERVER_DEV" '
        cd ~/bgTest/v5ToWindow
        
        echo "üìä Post-deployment verification..."
        
        # Extended availability test
        failed_checks=0
        total_checks=50
        
        for i in $(seq 1 $total_checks); do
          if ! curl -f --max-time 3 "http://localhost:80/status" >/dev/null 2>&1; then
            failed_checks=$((failed_checks + 1))
          fi
          sleep 1
        done
        
        availability=$(echo "scale=2; (1 - $failed_checks/$total_checks) * 100" | bc -l || echo "100")
        
        echo "üìà Deployment verification results:"
        echo "   - Total checks: $total_checks"
        echo "   - Failed checks: $failed_checks"
        echo "   - Availability: ${availability}%"
        
        if [ "$failed_checks" -eq 0 ]; then
          echo "üéâ ZERO-DOWNTIME DEPLOYMENT SUCCESSFUL!"
          echo "‚úÖ Perfect availability achieved: 100%"
        elif [ "$failed_checks" -le 2 ]; then
          echo "‚ö†Ô∏è  Deployment completed with minor issues"
          echo "   Availability: ${availability}%"
        else
          echo "‚ùå Deployment verification failed"
          echo "   Too many availability issues detected"
          exit 1
        fi
      '

# 9. Cleanup Previous Environment (Manual) - Advanced Container Cleanup
cleanup-previous-environment:
  stage: cleanup-dev
  image: alpine:latest
  <<: [*ssh_setup, *rules_dev_main]
  needs: ["verify-deployment"]
  when: manual
  allow_failure: true
  timeout: 2h  # Extended timeout for comprehensive cleanup
  variables:
    CLEANUP_STRATEGY: "${CLEANUP_STRATEGY}"
    KEEP_INACTIVE_MINUTES: "${KEEP_INACTIVE_MINUTES}"
  script:
    - echo "üßπ Starting comprehensive Blue-Green container cleanup..."
    - echo "üìä Cleanup Configuration:"
    - echo "   Strategy: ${CLEANUP_STRATEGY}"
    - echo "   Inactive retention: ${KEEP_INACTIVE_MINUTES} minutes"
    - |
      ssh "ubuntu@$DEPLOY_SERVER_DEV" '
        export CLEANUP_STRATEGY="'${CLEANUP_STRATEGY}'"
        export KEEP_INACTIVE_MINUTES="'${KEEP_INACTIVE_MINUTES}'"
        cd ~/bgTest/v5ToWindow
        
        # Enhanced cleanup script with safety mechanisms
        
        # === PHASE 1: ENVIRONMENT DETECTION AND VALIDATION ===
        echo "üîç Phase 1: Environment Detection and Validation"
        
        # Detect current active environment with multiple fallback methods
        CURRENT_ACTIVE=""
        DEPLOY_TARGET=""
        
        echo "üìä Detecting current active environment..."
        
        # Method 1: API-based detection (most reliable)
        if docker ps --filter "name=api-server" --format "{{.Names}}" | grep -q api-server; then
          API_RESPONSE=$(docker run --rm --network bluegreen-network curlimages/curl:latest \
            curl -s --max-time 5 "http://api-server:9000/status" 2>/dev/null || echo "")
          API_ACTIVE=$(echo "$API_RESPONSE" | jq -r ".current_deployment" 2>/dev/null || echo "")
          
          if [ -n "$API_ACTIVE" ] && [ "$API_ACTIVE" != "null" ]; then
            CURRENT_ACTIVE="$API_ACTIVE"
            echo "‚úÖ API-detected active environment: $CURRENT_ACTIVE"
          fi
        fi
        
        # Method 2: File-based detection (fallback)
        if [ -z "$CURRENT_ACTIVE" ]; then
          FILE_ACTIVE=$(docker exec nginx-proxy cat /etc/nginx/conf.d/active.env 2>/dev/null | grep -o "blue\|green" || echo "")
          if [ -n "$FILE_ACTIVE" ]; then
            CURRENT_ACTIVE="$FILE_ACTIVE"
            echo "üìÑ File-detected active environment: $CURRENT_ACTIVE"
          fi
        fi
        
        # Method 3: Default fallback
        if [ -z "$CURRENT_ACTIVE" ]; then
          CURRENT_ACTIVE="blue"
          echo "‚ö†Ô∏è  No active environment detected, defaulting to: $CURRENT_ACTIVE"
        fi
        
        # Determine inactive environment
        if [ "$CURRENT_ACTIVE" = "blue" ]; then
          INACTIVE_ENV="green"
        else
          INACTIVE_ENV="blue"
        fi
        
        echo "üìä Environment Status:"
        echo "   Current Active: $CURRENT_ACTIVE"
        echo "   Inactive Environment: $INACTIVE_ENV"
        
        # === PHASE 2: PRE-CLEANUP HEALTH CHECK ===
        echo ""
        echo "üè• Phase 2: Pre-Cleanup System Health Check"
        
        # Verify system stability before cleanup
        echo "üîç Verifying system stability..."
        
        # Check active environment health
        active_container="${CURRENT_ACTIVE}-app"
        if docker ps --filter "name=$active_container" --format "{{.Names}}" | grep -q "$active_container"; then
          echo "‚úÖ Active environment ($active_container) is running"
          
          # Health check active environment
          active_port=$(if [ "$CURRENT_ACTIVE" = "blue" ]; then echo "3001"; else echo "3002"; fi)
          if docker exec "$active_container" sh -c "curl -sS -f --max-time 3 http://localhost:$active_port/health >/dev/null" 2>/dev/null; then
            echo "‚úÖ Active environment health check passed"
          else
            echo "‚ùå Active environment health check failed - aborting cleanup"
            exit 1
          fi
        else
          echo "‚ùå Active environment container not found - aborting cleanup"
          exit 1
        fi
        
        # Check nginx proxy
        if docker ps --filter "name=nginx-proxy" --format "{{.Names}}" | grep -q nginx-proxy; then
          echo "‚úÖ NGINX proxy is running"
        else
          echo "‚ùå NGINX proxy not running - aborting cleanup"
          exit 1
        fi
        
        # === PHASE 3: CONTAINER INVENTORY AND ANALYSIS ===
        echo ""
        echo "üì¶ Phase 3: Container Inventory and Analysis"
        
        # Get current container inventory
        echo "üîç Current container inventory:"
        docker ps -a --format "table {{.Names}}\t{{.Status}}\t{{.CreatedAt}}\t{{.Image}}" | grep -E "(blue|green|nginx|api)" || echo "No Blue-Green containers found"
        
        # Get Docker images inventory
        echo ""
        echo "üîç Current image inventory:"
        docker images --format "table {{.Repository}}\t{{.Tag}}\t{{.CreatedAt}}\t{{.Size}}" | grep -E "(blue|green|bgtest|v5towindow)" || echo "No project images found"
        
        # Identify containers to cleanup with Blue-Green deployment awareness
        echo ""
        echo "üéØ Identifying containers for cleanup (Blue-Green Deployment Mode):"
        
        # Determine cleanup strategy based on environment variables (default: aggressive)
        CLEANUP_STRATEGY="${CLEANUP_STRATEGY:-aggressive}"
        KEEP_INACTIVE_MINUTES="${KEEP_INACTIVE_MINUTES:-5}"  # Keep inactive for 5 minutes for rollback safety
        
        echo "üìã Cleanup Configuration:"
        echo "   Strategy: $CLEANUP_STRATEGY"
        echo "   Inactive retention: $KEEP_INACTIVE_MINUTES minutes"
        echo "   Active environment: $CURRENT_ACTIVE"
        
        # Essential services that should never be removed
        essential_services="nginx-proxy api-server"
        
        # Blue-Green environment containers
        blue_container="blue-app"
        green_container="green-app"
        active_container="${CURRENT_ACTIVE}-app"
        inactive_container=""
        
        if [ "$CURRENT_ACTIVE" = "blue" ]; then
          inactive_container="green-app"
        else
          inactive_container="blue-app"
        fi
        
        echo "üîç Blue-Green Container Analysis:"
        echo "   Active container: $active_container"
        echo "   Inactive container: $inactive_container"
        
        cleanup_containers=""
        
        # Check if containers exist and their status
        blue_exists=$(docker ps -a --format "{{.Names}}" | grep -c "^blue-app$" || echo "0")
        green_exists=$(docker ps -a --format "{{.Names}}" | grep -c "^green-app$" || echo "0")
        
        echo "üìä Container Existence Check:"
        echo "   blue-app exists: $(if [ "$blue_exists" = "1" ]; then echo "Yes"; else echo "No"; fi)"
        echo "   green-app exists: $(if [ "$green_exists" = "1" ]; then echo "Yes"; else echo "No"; fi)"
        
        # Blue-Green Cleanup Logic
        case "$CLEANUP_STRATEGY" in
          "aggressive")
            # Immediately remove inactive environment (resource-optimized for AWS t2.micro)
            echo "üöÄ Aggressive cleanup mode: Removing inactive environment immediately"
            
            if [ "$inactive_container" != "$active_container" ]; then
              if docker ps -a --format "{{.Names}}" | grep -q "^${inactive_container}$"; then
                # Check if inactive container has been running longer than safety window
                container_age=$(docker inspect "$inactive_container" --format "{{.Created}}" 2>/dev/null || echo "")
                if [ -n "$container_age" ]; then
                  current_time=$(date +%s)
                  container_time=$(date -d "$container_age" +%s 2>/dev/null || echo "0")
                  time_diff_minutes=$(((current_time - container_time) / 60))
                  
                  if [ $time_diff_minutes -gt $KEEP_INACTIVE_MINUTES ]; then
                    cleanup_containers="$cleanup_containers $inactive_container"
                    echo "üóëÔ∏è  Marking inactive environment for cleanup: $inactive_container (inactive for $time_diff_minutes minutes)"
                  else
                    echo "‚è∞ Keeping inactive container for rollback safety: $inactive_container (inactive for $time_diff_minutes minutes, threshold: $KEEP_INACTIVE_MINUTES min)"
                  fi
                else
                  cleanup_containers="$cleanup_containers $inactive_container"
                  echo "üóëÔ∏è  Marking inactive environment for cleanup: $inactive_container (age unknown)"
                fi
              else
                echo "‚ÑπÔ∏è  Inactive container $inactive_container does not exist"
              fi
            fi
            ;;
            
          "conservative")
            # Keep both environments (original behavior with time-based cleanup)
            echo "üõ°Ô∏è  Conservative cleanup mode: Time-based cleanup only"
            
            for container in blue-app green-app; do
              if [ "$container" != "$active_container" ]; then
                if docker ps -a --format "{{.Names}}" | grep -q "^${container}$"; then
                  container_age=$(docker inspect "$container" --format "{{.Created}}" 2>/dev/null || echo "")
                  if [ -n "$container_age" ]; then
                    current_time=$(date +%s)
                    container_time=$(date -d "$container_age" +%s 2>/dev/null || echo "0")
                    time_diff_hours=$((time_diff / 3600))
                    
                    if [ $time_diff_hours -gt 24 ]; then  # Keep for 24 hours
                      cleanup_containers="$cleanup_containers $container"
                      echo "üóëÔ∏è  Marking old container for cleanup: $container (created $time_diff_hours hours ago)"
                    else
                      echo "‚è∞ Keeping recent container: $container (created $time_diff_hours hours ago)"
                    fi
                  fi
                fi
              fi
            done
            ;;
            
          "balanced")
            # Keep current + 1 previous for rollback, remove older versions
            echo "‚öñÔ∏è  Balanced cleanup mode: Keep current + 1 previous version"
            
            # This would require version tracking - simplified to aggressive for now
            if [ "$inactive_container" != "$active_container" ]; then
              if docker ps -a --format "{{.Names}}" | grep -q "^${inactive_container}$"; then
                container_age=$(docker inspect "$inactive_container" --format "{{.Created}}" 2>/dev/null || echo "")
                if [ -n "$container_age" ]; then
                  current_time=$(date +%s)
                  container_time=$(date -d "$container_age" +%s 2>/dev/null || echo "0")
                  time_diff_minutes=$(((current_time - container_time) / 60))
                  
                  if [ $time_diff_minutes -gt 30 ]; then  # Keep for 30 minutes for rollback
                    cleanup_containers="$cleanup_containers $inactive_container"
                    echo "üóëÔ∏è  Marking previous version for cleanup: $inactive_container (inactive for $time_diff_minutes minutes)"
                  else
                    echo "‚è∞ Keeping previous version for rollback: $inactive_container (inactive for $time_diff_minutes minutes)"
                  fi
                fi
              fi
            fi
            ;;
        esac
        
        # Additional cleanup: Find any other old blue/green containers
        echo "üîç Scanning for additional outdated Blue-Green containers..."
        other_containers=$(docker ps -a --format "{{.Names}}" | grep -E "^(blue|green).*app" | grep -v -E "^(blue-app|green-app)$" || echo "")
        if [ -n "$other_containers" ]; then
          for container in $other_containers; do
            cleanup_containers="$cleanup_containers $container"
            echo "üóëÔ∏è  Found additional outdated container: $container"
          done
        fi
        
        # Protect essential services
        for essential in $essential_services; do
          if echo "$cleanup_containers" | grep -q "$essential"; then
            cleanup_containers=$(echo "$cleanup_containers" | sed "s/$essential//g")
            echo "üîí Protected essential service: $essential"
          fi
        done
        
        # Final cleanup containers list
        cleanup_containers=$(echo "$cleanup_containers" | tr ' ' '\n' | grep -v "^$" | tr '\n' ' ' | sed 's/ $//')
        
        if [ -n "$cleanup_containers" ]; then
          echo "üìã Final cleanup target list:$cleanup_containers"
        else
          echo "‚ÑπÔ∏è  No containers identified for cleanup based on current strategy ($CLEANUP_STRATEGY)"
        fi
        
        # === PHASE 4: SAFE CONTAINER REMOVAL ===
        echo ""
        echo "üóëÔ∏è  Phase 4: Safe Container Removal"
        
        if [ -n "$cleanup_containers" ]; then
          echo "üö® Containers scheduled for removal:$cleanup_containers"
          echo "‚ö†Ô∏è  Final safety check - ensuring active environment protection..."
          
          # Double-check we are not removing active environment
          for container in $cleanup_containers; do
            if [ "$container" = "${CURRENT_ACTIVE}-app" ]; then
              echo "‚ùå CRITICAL ERROR: Attempted to remove active environment container: $container"
              echo "‚ùå Aborting cleanup to prevent service disruption"
              exit 1
            fi
          done
          
          echo "‚úÖ Safety check passed - proceeding with container removal"
          
          for container in $cleanup_containers; do
            if docker ps -a --format "{{.Names}}" | grep -q "^${container}$"; then
              echo "üóëÔ∏è  Removing container: $container"
              
              # Stop container gracefully first
              if docker ps --format "{{.Names}}" | grep -q "^${container}$"; then
                echo "   ‚èπÔ∏è  Stopping container: $container"
                docker stop "$container" --time 30 || echo "   ‚ö†Ô∏è  Force stop may be required"
              fi
              
              # Remove container
              docker rm "$container" && echo "   ‚úÖ Container removed: $container" || echo "   ‚ùå Failed to remove: $container"
            else
              echo "   ‚ö†Ô∏è  Container not found: $container"
            fi
          done
        else
          echo "‚ÑπÔ∏è  No containers identified for cleanup"
        fi
        
        # === PHASE 5: DOCKER IMAGE CLEANUP ===
        echo ""
        echo "üñºÔ∏è  Phase 5: Docker Image Cleanup"
        
        echo "üîç Identifying unused Docker images..."
        
        # Get images that are not currently used by any container
        unused_images=$(docker images --filter "dangling=true" -q 2>/dev/null || echo "")
        
        if [ -n "$unused_images" ]; then
          echo "üóëÔ∏è  Found $(echo $unused_images | wc -w) dangling images"
          echo "üóëÔ∏è  Removing dangling images..."
          docker rmi $unused_images && echo "‚úÖ Dangling images removed" || echo "‚ö†Ô∏è  Some images could not be removed"
        else
          echo "‚ÑπÔ∏è  No dangling images found"
        fi
        
        # Remove old project-specific images (keep last 3 versions)
        echo "üîç Cleaning up old project images..."
        project_images=$(docker images --format "{{.Repository}}:{{.Tag}}" | grep -E "(bgtest|v5towindow)" | head -n -3 2>/dev/null || echo "")
        
        if [ -n "$project_images" ]; then
          echo "üóëÔ∏è  Removing old project images (keeping last 3 versions)..."
          for image in $project_images; do
            echo "   üóëÔ∏è  Removing image: $image"
            docker rmi "$image" 2>/dev/null && echo "   ‚úÖ Image removed" || echo "   ‚ö†Ô∏è  Image in use or removal failed"
          done
        else
          echo "‚ÑπÔ∏è  No old project images to remove"
        fi
        
        # === PHASE 6: VOLUME AND NETWORK CLEANUP ===
        echo ""
        echo "üíæ Phase 6: Volume and Network Cleanup"
        
        echo "üîç Cleaning up unused volumes..."
        unused_volumes=$(docker volume ls -f dangling=true -q 2>/dev/null || echo "")
        if [ -n "$unused_volumes" ]; then
          echo "üóëÔ∏è  Found $(echo $unused_volumes | wc -w) unused volumes"
          docker volume rm $unused_volumes && echo "‚úÖ Unused volumes removed" || echo "‚ö†Ô∏è  Some volumes could not be removed"
        else
          echo "‚ÑπÔ∏è  No unused volumes found"
        fi
        
        echo "üîç Cleaning up unused networks..."
        # Only remove unused networks, but preserve the bluegreen-network
        docker network prune -f && echo "‚úÖ Unused networks cleaned up" || echo "‚ö†Ô∏è  Network cleanup had issues"
        
        # === PHASE 7: SYSTEM OPTIMIZATION ===
        echo ""
        echo "‚ö° Phase 7: System Optimization and Resource Recovery"
        
        echo "üßπ Running Docker system prune (keep last 24 hours)..."
        docker system prune -f --filter "until=24h" && echo "‚úÖ System prune completed" || echo "‚ö†Ô∏è  System prune had issues"
        
        # === PHASE 8: POST-CLEANUP VALIDATION ===
        echo ""
        echo "üîç Phase 8: Post-Cleanup Validation and Health Check"
        
        echo "üìä Final system status:"
        docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}" | grep -E "(blue|green|nginx|api)" || echo "No active containers found"
        
        # Verify active environment is still healthy
        echo ""
        echo "üè• Verifying active environment health after cleanup..."
        sleep 10  # Allow time for system stabilization
        
        active_port=$(if [ "$CURRENT_ACTIVE" = "blue" ]; then echo "3001"; else echo "3002"; fi)
        for attempt in $(seq 1 5); do
          if docker exec "$active_container" sh -c "curl -sS -f --max-time 3 http://localhost:$active_port/health >/dev/null" 2>/dev/null; then
            echo "‚úÖ Active environment ($CURRENT_ACTIVE) health verified (attempt $attempt/5)"
            break
          else
            if [ $attempt -eq 5 ]; then
              echo "‚ùå Active environment health check failed after cleanup"
              echo "üö® Manual intervention may be required"
              exit 1
            else
              echo "‚è≥ Health check attempt $attempt/5 failed, retrying..."
              sleep 5
            fi
          fi
        done
        
        # Test main proxy access
        echo "üåê Testing main proxy access..."
        if curl -sS -f --max-time 5 "http://localhost:80/health" >/dev/null 2>&1; then
          echo "‚úÖ Main proxy access verified"
        else
          echo "‚ö†Ô∏è  Main proxy access test failed - may require attention"
        fi
        
        # === PHASE 9: RESOURCE USAGE REPORT ===
        echo ""
        echo "üìä Phase 9: Resource Usage Report"
        
        echo "üíæ Current disk usage:"
        df -h / | tail -n 1
        
        echo ""
        echo "üê≥ Current Docker resource usage:"
        docker system df
        
        echo ""
        echo "üìã Final container inventory:"
        docker ps -a --format "table {{.Names}}\t{{.Status}}\t{{.Image}}\t{{.CreatedAt}}"
        
        echo ""
        echo "üéâ =================================="
        echo "üéâ CLEANUP COMPLETED SUCCESSFULLY!"
        echo "üéâ =================================="
        echo "‚úÖ Active Environment: $CURRENT_ACTIVE (Protected and Verified)"
        echo "‚úÖ System Health: Validated"
        echo "‚úÖ Resources: Optimized"
        echo "‚úÖ Rollback Capability: Preserved"
        echo ""
        echo "üìã Summary:"
        echo "   - Containers cleaned up: $(echo $cleanup_containers | wc -w 2>/dev/null || echo 0)"
        echo "   - Active environment: Protected and healthy"
        echo "   - System resources: Optimized for AWS t2.micro"
        echo "   - Emergency rollback: Available via emergency-rollback job"
        echo ""
        echo "‚ö†Ô∏è  Note: Both Blue and Green environments remain deployable"
        echo "‚ö†Ô∏è  Emergency rollback is available if needed"
      '

# 10. Emergency Rollback (Manual).
emergency-rollback:
  stage: cleanup-dev
  image: alpine:latest
  <<: [*ssh_setup, *rules_dev_main]
  when: manual
  allow_failure: true
  environment:
    name: production-dev
    url: "http://$DEPLOY_SERVER_DEV"
  script:
    - echo "üö® EMERGENCY ROLLBACK - Immediate traffic restoration"
    - |
      ssh "ubuntu@$DEPLOY_SERVER_DEV" '
        cd ~/bgTest/v5ToWindow
        PREVIOUS_ACTIVE=$(cat ~/current_active.env 2>/dev/null || echo "blue")
        
        echo "üîÑ Emergency rollback to $PREVIOUS_ACTIVE environment..."
        
        # Execute rollback via API - using Docker internal network
        rollback_response=$(docker run --rm --network bluegreen-network curlimages/curl:latest \
          curl -s -X POST "http://api-server:9000/switch/$PREVIOUS_ACTIVE" 2>/dev/null || echo "{\"success\":false}")
        
        if echo "$rollback_response" | jq -e ".success" >/dev/null 2>&1; then
          echo "‚úÖ Emergency rollback successful - traffic restored to $PREVIOUS_ACTIVE"
        else
          echo "‚ùå Emergency rollback failed - manual intervention required"
          exit 1
        fi
        
        # Verify rollback
        if curl -f "http://localhost:80/status" >/dev/null 2>&1; then
          echo "‚úÖ Rollback verification successful"
        else
          echo "‚ùå Rollback verification failed"
        fi
      '