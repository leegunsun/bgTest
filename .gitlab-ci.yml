---
# True Blue-Green Deployment CI/CD Pipeline
# Implements zero-downtime deployment with separated container architecture

default:
  tags:
#    - mac-mini
    - home-runner

stages:
  - build-dev
  - test-dev
  - detect-env-dev
  - deploy-inactive-dev
  - health-check-dev
  - zero-downtime-test-dev
  - switch-traffic-dev
  - verify-deployment-dev
  - cleanup-dev

# Common variables.
variables:
  GIT_DEPTH: "0"
#  CI_DEBUG_TRACE: "true"  # ÏÉÅÏÑ∏ ÎîîÎ≤ÑÍ∑∏ Î°úÍ∑∏ ÌôúÏÑ±Ìôî
  NODE_OPTIONS: "--max_old_space_size=2048"
  DOCKER_DRIVER: overlay2
  COMPOSE_FILE: "docker-compose.yml"
  # Dynamic versioning support
  BLUE_VERSION: "${CI_COMMIT_TAG:-${CI_COMMIT_SHORT_SHA}}"
  GREEN_VERSION: "${CI_COMMIT_TAG:-${CI_COMMIT_SHORT_SHA}}"
  DEPLOYMENT_VERSION: "${CI_COMMIT_TAG:-${CI_COMMIT_SHORT_SHA}}"

# Reusable rules
.rules_dev_and_main: &rules_dev_main
  rules:
    - if: '$CI_COMMIT_BRANCH == "dev"'
    - if: '$CI_COMMIT_BRANCH == "main"'
    - when: never

# Reusable SSH setup
.ssh_setup: &ssh_setup
  before_script:
    - apk add --no-cache bash openssh-client curl jq docker docker-compose
    - eval $(ssh-agent -s)
    - echo "üîç Validating CI/CD Variables..."
    - |
      if [ -z "$AWS_PEM_DEV" ] || [ -z "$DEPLOY_SERVER_DEV" ]; then
        echo "‚ùå ERROR: Required CI/CD variables not configured"
        echo "Required: AWS_PEM_DEV (File), DEPLOY_SERVER_DEV (Variable)"
        exit 1
      fi
    - chmod 600 "$AWS_PEM_DEV"
    - ssh-add "$AWS_PEM_DEV"
    - mkdir -p ~/.ssh
    - echo -e "Host *\n\tStrictHostKeyChecking no\n" > ~/.ssh/config
    - echo "‚úÖ SSH setup completed"

# 1. Build Stage
build-dev:
  stage: build-dev
  image: node:18-alpine
  <<: *rules_dev_main
  script:
    - echo "üèóÔ∏è  Building Blue-Green unified architecture with version ${DEPLOYMENT_VERSION}..."
    - cp "$DEV_ENV_FILE" ./.env || echo "No env file configured"
    - echo "VERSION=${DEPLOYMENT_VERSION}" >> ./.env
    - echo "üì¶ Preparing artifacts for unified container deployment..."
    - echo "üîß Version configuration:"
    - echo "   BLUE_VERSION=${BLUE_VERSION}"
    - echo "   GREEN_VERSION=${GREEN_VERSION}"
    - echo "   DEPLOYMENT_VERSION=${DEPLOYMENT_VERSION}"
    - ls -la app-service/ api-service/ monitoring/ app-server/ || echo "Service directories ready"
  artifacts:
    expire_in: 3 days
    paths:
      - ./app-service/
      - ./api-service/
      - ./monitoring/
      - ./scripts/
      - ./app-server/
      - ./nginx.conf
      - ./conf.d/
      - ./admin.html
      - ./docker-compose.yml
      - ./.env

# 2. Test Stage
test-dev:
  stage: test-dev
  image: node:18-alpine
  <<: *rules_dev_main
  needs: ["build-dev"]
  script:
    - echo "üß™ Testing unified services architecture (True Blue-Green Pattern)..."
    - node -c app-server/app.js
    - node -c api-server/app.js
    - echo "‚úÖ All service syntax checks passed - Single codebase architecture"

# 3. Environment Detection
detect-active-environment:
  stage: detect-env-dev
  image: alpine:latest
  <<: [*ssh_setup, *rules_dev_main]
  needs: ["build-dev", "test-dev"]
  script:
#    - set -x  # Î™®Îì† Î™ÖÎ†πÏñ¥ Ï∂úÎ†•
    - echo "üîç Detecting current active environment..."
    - |
      ssh "ubuntu@$DEPLOY_SERVER_DEV" '
        cd ~/bgTest/v5ToWindow
        echo "üìä Environment Detection:"
        
        # Enhanced environment detection with API fallback
        echo "üîç Detecting current environment with multiple methods..."
        
        if docker ps --filter "name=nginx-proxy" --format "table {{.Names}}" | grep -q nginx-proxy; then
          echo "‚úÖ Blue-Green system is running"
          
          # Try API-based detection first (more reliable) - using Docker internal network
          API_RESPONSE=$(docker run --rm --network bluegreen-network curlimages/curl:latest \
            curl -s --max-time 5 "http://api-server:9000/status" 2>/dev/null || echo "")
          API_ACTIVE=$(echo "$API_RESPONSE" | jq -r ".current_deployment" 2>/dev/null || echo "")
          
          # Fallback to file-based detection
          FILE_ACTIVE=$(docker exec nginx-proxy cat /etc/nginx/conf.d/active.env | grep -o "blue\|green" 2>/dev/null || echo "")
          
          # Choose the most reliable source
          if [ -n "$API_ACTIVE" ] && [ "$API_ACTIVE" != "null" ]; then
            CURRENT_ACTIVE="$API_ACTIVE"
            echo "üìä Using API-detected environment: $CURRENT_ACTIVE"
          elif [ -n "$FILE_ACTIVE" ]; then
            CURRENT_ACTIVE="$FILE_ACTIVE"
            echo "üìÑ Using file-detected environment: $CURRENT_ACTIVE"
          else
            CURRENT_ACTIVE="blue"
            echo "‚ö†Ô∏è  No reliable detection, defaulting to: $CURRENT_ACTIVE"
          fi
          
          # True Blue-Green deployment: Deploy to inactive environment
          if [ "$CURRENT_ACTIVE" = "blue" ]; then
            DEPLOY_TARGET="green"
            echo "üîµ‚Üíüü¢ Current: blue, Deploying to: green"
          else
            DEPLOY_TARGET="blue"
            echo "üü¢‚Üíüîµ Current: green, Deploying to: blue"
          fi
        else
          echo "‚ö†Ô∏è  System not running, defaulting to green deployment"
          CURRENT_ACTIVE="blue"
          DEPLOY_TARGET="green"
        fi
        
        echo "Current active: $CURRENT_ACTIVE"
        echo "Deploy target: $DEPLOY_TARGET"
        
        # Save environment info
        echo "$CURRENT_ACTIVE" > ~/current_active.env
        echo "$DEPLOY_TARGET" > ~/deploy_target.env
      '

# 4. Deploy to Inactive Environment ONLY (ZERO DOWNTIME)
deploy-to-inactive-environment:
  stage: deploy-inactive-dev
  image: alpine:latest
  <<: [*ssh_setup, *rules_dev_main]
  needs: ["detect-active-environment"]
  environment:
    name: inactive-env
    url: "http://$DEPLOY_SERVER_DEV"
  script:
    - echo "üöÄ TRUE BLUE-GREEN DEPLOYMENT - Deploy to inactive environment only"
    - echo "üìÅ Transferring unified service architecture..."
    - ssh "ubuntu@$DEPLOY_SERVER_DEV" "mkdir -p ~/bgTest/v5ToWindow"
    - scp -r ./app-service/ "ubuntu@$DEPLOY_SERVER_DEV:~/bgTest/v5ToWindow/"
    - scp -r ./api-service/ "ubuntu@$DEPLOY_SERVER_DEV:~/bgTest/v5ToWindow/"
    - scp -r ./api-server/ "ubuntu@$DEPLOY_SERVER_DEV:~/bgTest/v5ToWindow/"
    - scp -r ./monitoring/ "ubuntu@$DEPLOY_SERVER_DEV:~/bgTest/v5ToWindow/"
    - scp -r ./app-server/ "ubuntu@$DEPLOY_SERVER_DEV:~/bgTest/v5ToWindow/"
    - ssh "ubuntu@$DEPLOY_SERVER_DEV" "mkdir -p ~/bgTest/v5ToWindow/conf.d"
    - scp ./conf.d/upstreams.conf "ubuntu@$DEPLOY_SERVER_DEV:~/bgTest/v5ToWindow/conf.d/"
    - scp ./conf.d/routing.conf "ubuntu@$DEPLOY_SERVER_DEV:~/bgTest/v5ToWindow/conf.d/"
    - scp ./docker-compose.yml "ubuntu@$DEPLOY_SERVER_DEV:~/bgTest/v5ToWindow/"
    - scp ./nginx.conf "ubuntu@$DEPLOY_SERVER_DEV:~/bgTest/v5ToWindow/"
    - scp ./admin.html "ubuntu@$DEPLOY_SERVER_DEV:~/bgTest/v5ToWindow/"
    - scp ./.env "ubuntu@$DEPLOY_SERVER_DEV:~/bgTest/v5ToWindow/" || echo "No .env file found, using defaults"
    - echo "üê≥ Deploying ONLY to inactive environment (maintaining zero downtime)..."
    - |
      ssh "ubuntu@$DEPLOY_SERVER_DEV" '
        cd ~/bgTest/v5ToWindow
        
        # True Blue-Green deployment: Deploy to inactive environment
        DEPLOY_TARGET=$(cat ~/deploy_target.env 2>/dev/null || echo "green")
        DEPLOY_VERSION="'${DEPLOYMENT_VERSION}'"
        echo "üéØ Deploying version $DEPLOY_VERSION to $DEPLOY_TARGET environment (True Blue-Green mode)"
        
        # Set version for target environment (True Blue-Green mode)
        if [ "$DEPLOY_TARGET" = "blue" ]; then
          export BLUE_VERSION="$DEPLOY_VERSION"
          echo "BLUE_VERSION=$DEPLOY_VERSION" >> .env
          echo "üîµ True Blue-Green: Setting BLUE_VERSION=$DEPLOY_VERSION"
        else
          export GREEN_VERSION="$DEPLOY_VERSION"
          echo "GREEN_VERSION=$DEPLOY_VERSION" >> .env
          echo "üü¢ True Blue-Green: Setting GREEN_VERSION=$DEPLOY_VERSION"
        fi
        
        # Ensure deployment metadata directory exists
        mkdir -p deployment_state
        
        # Install Docker if needed
        if ! command -v docker &> /dev/null; then
          echo "üì¶ Installing Docker..."
          curl -fsSL https://get.docker.com -o get-docker.sh
          sudo sh get-docker.sh
          sudo usermod -aG docker ubuntu
          sudo systemctl start docker
          sudo systemctl enable docker
        fi
        
        # Ensure Docker permissions and restart if needed
        sudo usermod -aG docker ubuntu
        sudo systemctl restart docker
        sudo chmod 666 /var/run/docker.sock || true
        newgrp docker || true
        
        # Install debugging tools
        sudo apt-get update -qq >/dev/null 2>&1 || true
        sudo apt-get install -y netcat-openbsd net-tools >/dev/null 2>&1 || true
        
        # Install Docker Compose if needed
        if ! command -v docker-compose &> /dev/null; then
          echo "üì¶ Installing Docker Compose..."
          sudo curl -L "https://github.com/docker/compose/releases/download/v2.24.0/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
          sudo chmod +x /usr/local/bin/docker-compose
          sudo ln -sf /usr/local/bin/docker-compose /usr/bin/docker-compose
        fi
        
        # Verify Docker is accessible
        echo "üîç Verifying Docker access..."
        if ! docker ps >/dev/null 2>&1 && ! sudo docker ps >/dev/null 2>&1; then
          echo "‚ùå Docker is not accessible. Please check Docker installation and permissions."
          exit 1
        fi
        
        # Check if system is already running
        if docker ps --filter "name=nginx-proxy" --format "table {{.Names}}" | grep -q nginx-proxy; then
          echo "‚úÖ System is running - deploying to inactive $DEPLOY_TARGET environment"
          
          # TRUE ZERO-DOWNTIME DEPLOYMENT - NO CONTAINER STOP/KILL
          echo "üîÑ Zero-downtime deployment to $DEPLOY_TARGET environment..."
          
          # Rebuild API server with latest fixes (network access issue resolution)
          echo "üîß Rebuilding API server with network access fixes..."
          docker-compose -f docker-compose.yml build api-server || sudo docker-compose -f docker-compose.yml build api-server
          docker-compose -f docker-compose.yml up -d --no-deps --force-recreate api-server || sudo docker-compose -f docker-compose.yml up -d --no-deps --force-recreate api-server
          
          # Rebuild target application environment
          echo "üéØ Rebuilding $DEPLOY_TARGET application environment..."
          docker-compose -f docker-compose.yml build ${DEPLOY_TARGET}-app || sudo docker-compose -f docker-compose.yml build ${DEPLOY_TARGET}-app
          docker-compose -f docker-compose.yml up -d --no-deps --force-recreate ${DEPLOY_TARGET}-app || sudo docker-compose -f docker-compose.yml up -d --no-deps --force-recreate ${DEPLOY_TARGET}-app
          
          echo "‚è≥ Waiting for API server and $DEPLOY_TARGET environment to be ready..."
          sleep 45  # Extended wait time for API server + target environment startup
          
          # Verify API server is accessible with new implementation
          echo "üîç Verifying API server accessibility..."
          for attempt in $(seq 1 10); do
            if docker run --rm --network bluegreen-network curlimages/curl:latest curl -s --max-time 3 "http://api-server:9000/health" >/dev/null; then
              echo "‚úÖ API server is responsive (attempt $attempt/10)"
              break
            else
              echo "‚è≥ API server not ready yet (attempt $attempt/10)..."
              sleep 5
            fi
            if [ $attempt -eq 10 ]; then
              echo "‚ùå API server failed to become ready after 10 attempts"
              echo "üîç Container status:"
              docker ps --filter "name=api-server"
              echo "üîç API server logs:"
              docker logs api-server --tail 50 || true
              exit 1
            fi
          done
          
        else
          echo "üèóÔ∏è  Initial system deployment - starting all services"
          
          # Initialize active.env for first deployment (True Blue-Green setup)
          if [ ! -f "conf.d/active.env" ]; then
            echo "üîß Initializing active.env for first deployment..."
            echo "set \$active \"green\";" > conf.d/active.env
            echo "‚úÖ Created initial active.env with green environment"
          else
            echo "‚ÑπÔ∏è  active.env already exists, preserving current configuration"
          fi
          
          docker-compose -f docker-compose.yml down --timeout 10 || sudo docker-compose -f docker-compose.yml down --timeout 10 || true
          docker-compose -f docker-compose.yml build || sudo docker-compose -f docker-compose.yml build
          docker-compose -f docker-compose.yml up -d || sudo docker-compose -f docker-compose.yml up -d
          
          echo "‚è≥ Waiting for all services to be ready (t2.micro needs more time)..."
          sleep 120
          
          # ÏÉÅÏÑ∏ ÎîîÎ≤ÑÍπÖ Ï†ïÎ≥¥ ÏàòÏßë
          echo "üîç [DEBUG] Container status check:"
          docker ps -a --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
          
          echo "üîç [DEBUG] Network information:"
          docker network ls
          docker network inspect bluegreen-network | jq ".[0].Containers" || true
          
          echo "üîç [DEBUG] System resource usage:"
          free -h || true
          df -h || true
        fi
        
        # Enhanced Docker-native health checking with internal network validation
        echo "üè• Health checking deployed $DEPLOY_TARGET environment with Docker-native methods..."
        TARGET_PORT=$(if [ "$DEPLOY_TARGET" = "blue" ]; then echo "3001"; else echo "3002"; fi)
        APP_CONTAINER="${DEPLOY_TARGET}-app"
        
        # Helper function: Get Docker health status
        get_docker_health_status() {
          if docker inspect --format='{{json .State.Health}}' "$1" >/dev/null 2>&1; then
            docker inspect --format='{{.State.Health.Status}}' "$1" 2>/dev/null || echo "no-health"
          else
            echo "no-health"
          fi
        }
        
        # Helper function: Internal container health check
        app_internal_health_check() {
          docker exec "$APP_CONTAINER" sh -c "curl -sS -f --max-time 5 http://localhost:$TARGET_PORT/health >/dev/null" 2>/dev/null
          return $?
        }
        
        # Helper function: Network-level health check via ephemeral container
        network_health_check() {
          docker run --rm --network bluegreen-network curlimages/curl:latest \
            -sS -f --max-time 5 "http://${APP_CONTAINER}:${TARGET_PORT}/health" >/dev/null 2>/dev/null
          return $?
        }
        
        # Enhanced health check loop with exponential backoff
        for attempt in $(seq 1 40); do
          echo "üîç Health check attempt $attempt/40 for $DEPLOY_TARGET (container: $APP_CONTAINER)"
          
          # Priority 1: Check Docker-managed health status
          HEALTH_STATUS=$(get_docker_health_status "$APP_CONTAINER")
          echo "üîé Docker Health Status: $HEALTH_STATUS"
          
          if [ "$HEALTH_STATUS" = "healthy" ]; then
            echo "‚úÖ Docker-level health = healthy"
            
            # Version verification via internal network
            DEPLOYED_VERSION=$(docker exec "$APP_CONTAINER" sh -c "curl -s --max-time 3 http://localhost:$TARGET_PORT/version 2>/dev/null | jq -r .version 2>/dev/null" || echo "unknown")
            if [ "$DEPLOYED_VERSION" != "unknown" ]; then
              echo "üìã Deployed version: $DEPLOYED_VERSION"
              DEPLOYMENT_ID=$(docker exec "$APP_CONTAINER" sh -c "curl -s --max-time 3 http://localhost:$TARGET_PORT/version 2>/dev/null | jq -r .deployment_id 2>/dev/null" || echo "unknown")
              echo "üÜî Deployment ID: $DEPLOYMENT_ID"
            fi
            break
          fi
          
          # Priority 2: Internal container health check
          echo "üîç Trying internal container health check (docker exec)..."
          if app_internal_health_check; then
            echo "‚úÖ Internal container health check passed"
            
            # Version verification
            DEPLOYED_VERSION=$(docker exec "$APP_CONTAINER" sh -c "curl -s --max-time 3 http://localhost:$TARGET_PORT/version 2>/dev/null | jq -r .version 2>/dev/null" || echo "unknown")
            echo "üìã Deployed version: $DEPLOYED_VERSION"
            break
          fi
          
          # Priority 3: Network-level health check via Docker network
          echo "üîç Trying network-level health check (ephemeral curl container)..."
          if network_health_check; then
            echo "‚úÖ Network-level health check passed"
            break
          fi
          
          # Enhanced debugging at key intervals
          if [ $attempt -eq 3 ] || [ $attempt -eq 10 ] || [ $attempt -eq 20 ] || [ $attempt -eq 35 ]; then
            echo "üîç [DEBUG] Container status (attempt $attempt):"
            docker ps -a --format "table {{.Names}}\\t{{.Status}}\\t{{.Ports}}" | grep -E "(nginx|${DEPLOY_TARGET}|api)" || true
            echo "üîç [DEBUG] Container logs (last 15 lines):"
            docker logs --tail 15 "$APP_CONTAINER" 2>&1 | head -20 || echo "‚ùå No logs for $APP_CONTAINER"
            echo "üîç [DEBUG] Container inspect state:"
            docker inspect --format='{{json .State}}' "$APP_CONTAINER" | jq '.Running, .Health.Status, .RestartCount, .ExitCode' 2>/dev/null || echo "‚ùå Inspect failed"
            echo "üîç [DEBUG] Network connectivity test:"
            docker exec "$APP_CONTAINER" sh -c "netstat -tulpn 2>/dev/null | grep :$TARGET_PORT || echo 'Port not bound inside container'"
          fi
          
          # Final attempt failure handling
          if [ $attempt -eq 40 ]; then
            echo "‚ùå $DEPLOY_TARGET environment failed to become healthy after $attempt attempts"
            echo "üîç [FINAL DEBUG] Complete diagnostic information:"
            docker ps -a --format "table {{.Names}}\\t{{.Status}}\\t{{.Ports}}"
            echo "üìã Final container logs:"
            docker logs --tail 50 "$APP_CONTAINER" 2>&1 || echo "No $APP_CONTAINER logs"
            docker logs --tail 20 api-server 2>&1 || echo "No api-server logs"  
            docker logs --tail 20 nginx-proxy 2>&1 || echo "No nginx-proxy logs"
            echo "üîç Final network and process state:"
            docker exec "$APP_CONTAINER" sh -c "ps aux; echo '---'; netstat -tulpn" 2>/dev/null || echo "Cannot access container internals"
            exit 1
          fi
          
          # Exponential backoff: progressively increase wait time
          sleep_duration=$(( 3 + attempt * 2 ))
          if [ $sleep_duration -gt 30 ]; then sleep_duration=30; fi
          echo "‚è≥ Waiting ${sleep_duration}s before next attempt (progressive backoff)..."
          sleep "$sleep_duration"
        done
        
        echo "üéâ Inactive environment deployment completed successfully with version tracking!"
      '

# 5. Health Check Inactive Environment
health-check-inactive-environment:
  stage: health-check-dev
  image: alpine:latest
  <<: [*ssh_setup, *rules_dev_main]
  needs: ["deploy-to-inactive-environment"]
  retry: 2
  script:
    - echo "üè• Comprehensive Docker-native health check of inactive environment..."
    - |
      ssh "ubuntu@$DEPLOY_SERVER_DEV" '
        cd ~/bgTest/v5ToWindow
        DEPLOY_TARGET=$(cat ~/deploy_target.env 2>/dev/null || echo "green")
        echo "üéØ Health checking $DEPLOY_TARGET environment using Docker-native methods..."
        
        APP_CONTAINER="${DEPLOY_TARGET}-app"
        TARGET_PORT=$(if [ "$DEPLOY_TARGET" = "blue" ]; then echo "3001"; else echo "3002"; fi)
        
        # Enhanced service health check with multiple validation layers
        check_service_enhanced() {
          local service_name="$1"
          local container_name="$2"
          local internal_port="$3"
          local proxy_url="$4"
          local max_attempts=12
          
          echo "üîç Enhanced health check for $service_name (container: $container_name)..."
          
          for attempt in $(seq 1 $max_attempts); do
            echo "üîç Attempt $attempt/$max_attempts for $service_name"
            
            # Method 1: Docker health status (if available)
            if docker inspect --format="{{.State.Health.Status}}" "$container_name" 2>/dev/null | grep -q "healthy"; then
              echo "‚úÖ $service_name: Docker health status = healthy"
              return 0
            fi
            
            # Method 2: Internal container health check
            if [ -n "$internal_port" ] && docker exec "$container_name" sh -c "curl -sS -f --max-time 3 http://localhost:$internal_port/health >/dev/null" 2>/dev/null; then
              echo "‚úÖ $service_name: Internal health check passed"
              return 0
            fi
            
            # Method 3: Network-level health check via ephemeral container
            if docker run --rm --network bluegreen-network curlimages/curl:latest -sS -f --max-time 3 "http://$container_name:$internal_port/health" >/dev/null 2>/dev/null; then
              echo "‚úÖ $service_name: Network-level health check passed"
              return 0
            fi
            
            # Method 4: Proxy-based health check (fallback for NGINX routing validation)
            if [ -n "$proxy_url" ] && curl -sS -f --max-time 3 "$proxy_url" >/dev/null 2>/dev/null; then
              echo "‚úÖ $service_name: Proxy-based health check passed"
              return 0
            fi
            
            # Progressive wait with exponential backoff
            wait_time=$(( 2 + attempt ))
            if [ $wait_time -gt 15 ]; then wait_time=15; fi
            echo "‚è≥ $service_name not ready, waiting ${wait_time}s... ($attempt/$max_attempts)"
            sleep "$wait_time"
          done
          
          echo "‚ùå $service_name health check failed after $max_attempts attempts"
          return 1
        }
        
        # Check core services with enhanced validation
        overall_status=0
        
        # Check target environment (blue or green) with comprehensive validation
        echo "üéØ Checking target environment: $DEPLOY_TARGET"
        if ! check_service_enhanced "$DEPLOY_TARGET Server" "$APP_CONTAINER" "$TARGET_PORT" "http://localhost/$DEPLOY_TARGET/health"; then
          overall_status=1
        fi
        
        # Check NGINX proxy with internal and external validation
        echo "üåê Checking NGINX Proxy"
        if ! check_service_enhanced "NGINX Proxy" "nginx-proxy" "" "http://localhost:80/health"; then
          echo "‚ö†Ô∏è NGINX proxy health check failed, but continuing..."
          # Note: Not failing overall status for NGINX as it might have different health endpoint behavior
        fi
        
        # Check API Server with internal-only validation (not exposed externally)
        echo "üîå Checking API Server (internal access only)"
        api_status=0
        if docker exec api-server sh -c "curl -sS -f --max-time 5 http://localhost:9000/health >/dev/null" 2>/dev/null; then
          echo "‚úÖ API Server: Internal health check passed"
        elif docker run --rm --network bluegreen-network curlimages/curl:latest -sS -f --max-time 5 "http://api-server:9000/health" >/dev/null 2>/dev/null; then
          echo "‚úÖ API Server: Network-level health check passed"
        else
          echo "‚ùå API Server health check failed"
          api_status=1
        fi
        
        # Enhanced debugging information
        if [ $overall_status -ne 0 ] || [ $api_status -ne 0 ]; then
          echo "üîç [DEBUG] System diagnostic information:"
          docker ps -a --format "table {{.Names}}\\t{{.Status}}\\t{{.Ports}}" | grep -E "(nginx|${DEPLOY_TARGET}|api)"
          echo "üîç [DEBUG] Container health states:"
          for container in nginx-proxy "$APP_CONTAINER" api-server; do
            if docker ps --format "{{.Names}}" | grep -q "^$container\$"; then
              health_status=$(docker inspect --format="{{.State.Health.Status}}" "$container" 2>/dev/null || echo "no-healthcheck")
              running_status=$(docker inspect --format="{{.State.Running}}" "$container" 2>/dev/null || echo "unknown")
              echo "  $container: Running=$running_status, Health=$health_status"
            fi
          done
          
          echo "üîç [DEBUG] Recent container logs:"
          docker logs --tail 10 "$APP_CONTAINER" 2>&1 | head -15 || echo "No logs for $APP_CONTAINER"
          docker logs --tail 10 nginx-proxy 2>&1 | head -15 || echo "No logs for nginx-proxy"
        fi
        
        # Final status evaluation
        if [ $overall_status -eq 0 ]; then
          if [ $api_status -eq 0 ]; then
            echo "üéâ All services are healthy - ready for traffic switch!"
          else
            echo "‚ö†Ô∏è Target environment is healthy but API server has issues - proceeding with caution"
          fi
        else
          echo "‚ùå Health check failed - deployment cannot proceed"
          echo "üîç Final container states:"
          docker ps -a --format "table {{.Names}}\\t{{.Status}}\\t{{.Ports}}"
          exit 1
        fi
      '

# 6. Zero-Downtime Test (Critical Validation).
zero-downtime-validation:
  stage: zero-downtime-test-dev
  image: alpine:latest
  <<: [*ssh_setup, *rules_dev_main]
  needs: ["health-check-inactive-environment"]
  script:
    - echo "üß™ Running zero-downtime deployment validation..."
    - |
      ssh "ubuntu@$DEPLOY_SERVER_DEV" '
        cd ~/bgTest/v5ToWindow
        echo "üöÄ Starting zero-downtime test before traffic switch..."
      
        # Quick availability test
        echo "üìä Testing current service availability..."
        for i in $(seq 1 30); do
          if ! curl -f --max-time 2 "http://localhost:80/status" >/dev/null 2>&1; then
            echo "‚ùå Service availability test failed"
            exit 1
          fi
          sleep 1
        done
      
        echo "‚úÖ Service is stable and ready for traffic switch"
      '

# 7. Switch Traffic (Manual Approval Required).
switch-traffic-to-inactive:
  stage: switch-traffic-dev
  image: alpine:latest
  <<: [*ssh_setup, *rules_dev_main]
  needs: ["zero-downtime-validation"]
  environment:
    name: production-dev
    url: "http://$DEPLOY_SERVER_DEV"
  when: manual
  allow_failure: false
  script:
    - echo "üîÑ ZERO-DOWNTIME TRAFFIC SWITCH - Manual approval granted"
    - |
      ssh "ubuntu@$DEPLOY_SERVER_DEV" '
        cd ~/bgTest/v5ToWindow
        DEPLOY_TARGET=$(cat ~/deploy_target.env 2>/dev/null || echo "green")
        
        echo "üö¶ Switching traffic to $DEPLOY_TARGET environment (True Blue-Green mode)..."
        
        # Debug: Check API server status first
        echo "üîç Debugging API server status..."
        echo "üìä Current container status:"
        docker ps --filter "name=api-server" --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
        
        echo "üîç Testing API server connectivity..."
        api_health=$(docker run --rm --network bluegreen-network curlimages/curl:latest \
          curl -s --max-time 5 "http://api-server:9000/health" 2>/dev/null || echo "API_UNREACHABLE")
        echo "üìä API health response: $api_health"
        
        # Execute traffic switch via API - using Docker internal network
        echo "üîÑ Executing switch command..."
        switch_response=$(docker run --rm --network bluegreen-network curlimages/curl:latest \
          curl -s -X POST "http://api-server:9000/switch/$DEPLOY_TARGET" 2>/dev/null || echo "{\"success\":false,\"error\":\"network_call_failed\"}")
        
        echo "üìä Raw switch response: $switch_response"
        
        if echo "$switch_response" | jq -e ".success" >/dev/null 2>&1; then
          echo "‚úÖ Traffic successfully switched to $DEPLOY_TARGET"
          echo "üìä Switch details: $switch_response"
        else
          echo "‚ùå Traffic switch failed: $switch_response"
          exit 1
        fi
        
        # Verify switch
        sleep 5
        if curl -f "http://localhost:80/status" >/dev/null 2>&1; then
          echo "‚úÖ Traffic switch verification successful"
        else
          echo "‚ùå Traffic switch verification failed"
          exit 1
        fi
      '

# 8. Deployment Verification.
verify-deployment:
  stage: verify-deployment-dev
  image: alpine:latest
  <<: [*ssh_setup, *rules_dev_main]
  needs: ["switch-traffic-to-inactive"]
  script:
    - echo "üîç Verifying zero-downtime deployment completion..."
    - |
      ssh "ubuntu@$DEPLOY_SERVER_DEV" '
        cd ~/bgTest/v5ToWindow
        
        echo "üìä Post-deployment verification..."
        
        # Extended availability test
        failed_checks=0
        total_checks=50
        
        for i in $(seq 1 $total_checks); do
          if ! curl -f --max-time 3 "http://localhost:80/status" >/dev/null 2>&1; then
            failed_checks=$((failed_checks + 1))
          fi
          sleep 1
        done
        
        availability=$(echo "scale=2; (1 - $failed_checks/$total_checks) * 100" | bc -l || echo "100")
        
        echo "üìà Deployment verification results:"
        echo "   - Total checks: $total_checks"
        echo "   - Failed checks: $failed_checks"
        echo "   - Availability: ${availability}%"
        
        if [ "$failed_checks" -eq 0 ]; then
          echo "üéâ ZERO-DOWNTIME DEPLOYMENT SUCCESSFUL!"
          echo "‚úÖ Perfect availability achieved: 100%"
        elif [ "$failed_checks" -le 2 ]; then
          echo "‚ö†Ô∏è  Deployment completed with minor issues"
          echo "   Availability: ${availability}%"
        else
          echo "‚ùå Deployment verification failed"
          echo "   Too many availability issues detected"
          exit 1
        fi
      '

# 9. Cleanup Previous Environment (Manual)
cleanup-previous-environment:
  stage: cleanup-dev
  image: alpine:latest
  <<: [*ssh_setup, *rules_dev_main]
  needs: ["verify-deployment"]
  when: manual
  allow_failure: true
  script:
    - echo "üßπ Cleaning up previous environment with proper container shutdown..."
    - |
      ssh "ubuntu@$DEPLOY_SERVER_DEV" '
        cd ~/bgTest/v5ToWindow
        
        # Configurable Timeout and Threshold Settings
        HEALTH_CHECK_ATTEMPTS=\${HEALTH_CHECK_ATTEMPTS:-10}
        HEALTH_CHECK_SUCCESS_THRESHOLD=\${HEALTH_CHECK_SUCCESS_THRESHOLD:-7}
        CONTAINER_STOP_TIMEOUT=\${CONTAINER_STOP_TIMEOUT:-30}
        FORCE_KILL_TIMEOUT=\${FORCE_KILL_TIMEOUT:-10}
        POST_CLEANUP_WAIT=\${POST_CLEANUP_WAIT:-5}
        HEALTH_CHECK_INTERVAL=\${HEALTH_CHECK_INTERVAL:-2}
        MIN_MEMORY_WARNING_MB=\${MIN_MEMORY_WARNING_MB:-100}
        HIGH_PROCESS_COUNT_WARNING=\${HIGH_PROCESS_COUNT_WARNING:-10}
        
        # Progressive Container Cleanup Configuration
        CLEANUP_STRATEGY=\${CLEANUP_STRATEGY:-"stop-only"}
        CLEANUP_DELAY_MINUTES=\${CLEANUP_DELAY_MINUTES:-0}
        ENABLE_ROLLBACK_PROTECTION=\${ENABLE_ROLLBACK_PROTECTION:-true}
        MIN_DISK_SPACE_GB=\${MIN_DISK_SPACE_GB:-1}
        VERIFY_IMAGE_BACKUP=\${VERIFY_IMAGE_BACKUP:-true}
        PROGRESSIVE_CLEANUP_STAGES=\${PROGRESSIVE_CLEANUP_STAGES:-"stop,remove"}
        
        echo "üßπ Container cleanup configuration:"
        echo "   Cleanup strategy: \$CLEANUP_STRATEGY"
        echo "   Cleanup delay: \$CLEANUP_DELAY_MINUTES minutes"
        echo "   Rollback protection: \$ENABLE_ROLLBACK_PROTECTION"
        echo "   Min disk space required: \${MIN_DISK_SPACE_GB}GB"
        echo "   Progressive stages: \$PROGRESSIVE_CLEANUP_STAGES"
        
        echo "üîß Using timeout configuration:"
        echo "   Health checks: \$HEALTH_CHECK_ATTEMPTS attempts (>\${HEALTH_CHECK_SUCCESS_THRESHOLD} required)"
        echo "   Container stop timeout: \${CONTAINER_STOP_TIMEOUT}s"
        echo "   Validation intervals: \${HEALTH_CHECK_INTERVAL}s"
        echo "   Post-cleanup wait: \${POST_CLEANUP_WAIT}s"
        echo ""
        
        # Enhanced Environment Detection and Validation
        echo "üîç Reading deployment environment information..."
        
        # Edge Case: Docker Service Availability Check
        if ! docker info >/dev/null 2>&1; then
          echo "‚ùå ERROR: Docker daemon is not running or not accessible"
          echo "   Please ensure Docker service is running and accessible"
          exit 1
        fi
        
        # Edge Case: Concurrent Operation Prevention
        CLEANUP_LOCK_FILE="/tmp/bluegreen-cleanup.lock"
        if [ -f "$CLEANUP_LOCK_FILE" ]; then
          cleanup_pid=$(cat "$CLEANUP_LOCK_FILE" 2>/dev/null || echo "unknown")
          if kill -0 "$cleanup_pid" 2>/dev/null; then
            echo "‚ùå ERROR: Another cleanup operation is currently running (PID: $cleanup_pid)"
            echo "   Wait for current cleanup to complete or remove lock file if stale"
            echo "   Lock file: $CLEANUP_LOCK_FILE"
            exit 1
          else
            echo "‚ö†Ô∏è  Removing stale cleanup lock file"
            rm -f "$CLEANUP_LOCK_FILE"
          fi
        fi
        
        # Create cleanup lock
        echo $$ > "$CLEANUP_LOCK_FILE"
        trap "rm -f $CLEANUP_LOCK_FILE; exit" INT TERM EXIT
        
        # Edge Case: System Resource Check
        echo "üîß Performing system resource validation..."
        available_memory=$(free -m | awk "/^Mem:/{print \$7}" 2>/dev/null || echo "0")
        if [ "$available_memory" -lt "\$MIN_MEMORY_WARNING_MB" ]; then
          echo "‚ö†Ô∏è  WARNING: Low available memory ($available_memory MB, threshold: \${MIN_MEMORY_WARNING_MB}MB)"
          echo "   Consider monitoring system performance during cleanup"
        fi
        
        CURRENT_ACTIVE=$(cat ~/current_active.env 2>/dev/null || echo "unknown")
        DEPLOY_TARGET=$(cat ~/deploy_target.env 2>/dev/null || echo "unknown")
        
        echo "Previous environment (to cleanup): $CURRENT_ACTIVE"
        echo "Current environment (keep running): $DEPLOY_TARGET"
        
        # Safety Validation 1: Environment Identification
        if [ "$CURRENT_ACTIVE" = "unknown" ] || [ "$DEPLOY_TARGET" = "unknown" ]; then
          echo "‚ùå ERROR: Cannot determine environment states from files"
          echo "   current_active.env: $CURRENT_ACTIVE"
          echo "   deploy_target.env: $DEPLOY_TARGET"
          echo "   ABORTING cleanup for safety"
          exit 1
        fi
        
        # Safety Validation 2: Different Environments
        if [ "$CURRENT_ACTIVE" = "$DEPLOY_TARGET" ]; then
          echo "‚ùå ERROR: Same environment detected ($CURRENT_ACTIVE = $DEPLOY_TARGET)"
          echo "   This indicates a deployment issue, aborting cleanup for safety"
          exit 1
        fi
        
        # Safety Validation 3: Valid Environment Names
        if [[ "$CURRENT_ACTIVE" != "blue" && "$CURRENT_ACTIVE" != "green" ]]; then
          echo "‚ùå ERROR: Invalid previous environment name: $CURRENT_ACTIVE"
          exit 1
        fi
        
        if [[ "$DEPLOY_TARGET" != "blue" && "$DEPLOY_TARGET" != "green" ]]; then
          echo "‚ùå ERROR: Invalid target environment name: $DEPLOY_TARGET"
          exit 1
        fi
        
        # Current Deployment Stability Verification
        echo "üè• Verifying current deployment stability before cleanup..."
        CURRENT_CONTAINER="${DEPLOY_TARGET}-app"
        CLEANUP_CONTAINER="${CURRENT_ACTIVE}-app"
        
        # Check current environment health
        current_health_checks=0
        for attempt in $(seq 1 \$HEALTH_CHECK_ATTEMPTS); do
          if docker exec "$CURRENT_CONTAINER" sh -c "curl -sS -f --max-time 3 http://localhost:$(if [ \"$DEPLOY_TARGET\" = \"blue\" ]; then echo 3001; else echo 3002; fi)/health >/dev/null" 2>/dev/null; then
            current_health_checks=$((current_health_checks + 1))
          fi
          sleep \$HEALTH_CHECK_INTERVAL
        done
        
        if [ \$current_health_checks -lt \$HEALTH_CHECK_SUCCESS_THRESHOLD ]; then
          echo "‚ùå ERROR: Current deployment ($DEPLOY_TARGET) not stable enough for cleanup"
          echo "   Health checks passed: \$current_health_checks/\$HEALTH_CHECK_ATTEMPTS (minimum \$HEALTH_CHECK_SUCCESS_THRESHOLD required)"
          echo "   ABORTING cleanup - fix current deployment first"
          exit 1
        fi
        
        echo "‚úÖ Current deployment ($DEPLOY_TARGET) is stable: \$current_health_checks/\$HEALTH_CHECK_ATTEMPTS health checks passed"
        
        # Verify traffic is routed to current environment
        echo "üö¶ Verifying traffic routing to current environment..."
        active_env_check=$(docker exec nginx-proxy cat /etc/nginx/conf.d/active.env | grep -o "blue\\|green" 2>/dev/null || echo "unknown")
        
        if [ "$active_env_check" != "$DEPLOY_TARGET" ]; then
          echo "‚ùå ERROR: Traffic routing mismatch"
          echo "   NGINX routing: $active_env_check"
          echo "   Expected: $DEPLOY_TARGET"
          echo "   ABORTING cleanup - fix traffic routing first"
          exit 1
        fi
        
        echo "‚úÖ Traffic correctly routed to $DEPLOY_TARGET environment"
        
        # Check if cleanup container is running
        echo "üîç Checking previous environment container status..."
        if ! docker ps --format "{{.Names}}" | grep -q "^$CLEANUP_CONTAINER\\$"; then
          echo "‚ÑπÔ∏è  Container $CLEANUP_CONTAINER is already stopped"
          echo "‚úÖ Cleanup already completed - no action needed"
          exit 0
        fi
        
        echo "üìä Container $CLEANUP_CONTAINER is currently running - proceeding with cleanup"
        
        # Enhanced Pre-cleanup Resource Monitoring
        echo "üìä Pre-cleanup system resource analysis:"
        
        # System-wide metrics
        total_memory=$(free -m | awk "/^Mem:/{print \$2}" 2>/dev/null || echo "unknown")
        used_memory=$(free -m | awk "/^Mem:/{print \$3}" 2>/dev/null || echo "unknown")
        free_space=$(df -h . | awk "NR==2{print \$4}" 2>/dev/null || echo "unknown")
        load_avg=$(uptime | awk -F"load average:" '{print \$2}' | sed 's/^[[:space:]]*//' 2>/dev/null || echo "unknown")
        
        echo "   üíª System: Memory \${used_memory}/\${total_memory}MB, Disk free: \$free_space, Load: \$load_avg"
        
        # Container-specific metrics with error handling
        echo "   üê≥ Container resource usage:"
        for container in $CLEANUP_CONTAINER $CURRENT_CONTAINER nginx-proxy api-server; do
          if docker ps --format "{{.Names}}" | grep -q "^\$container\$"; then
            cpu_usage=$(docker stats --no-stream --format "{{.CPUPerc}}" \$container 2>/dev/null | sed 's/%//' || echo "N/A")
            mem_usage=$(docker stats --no-stream --format "{{.MemUsage}}" \$container 2>/dev/null || echo "N/A")
            mem_perc=$(docker stats --no-stream --format "{{.MemPerc}}" \$container 2>/dev/null | sed 's/%//' || echo "N/A")
            echo "      \$container: CPU \${cpu_usage}%, Memory \$mem_usage (\${mem_perc}%)"
            
            # Store cleanup container metrics for comparison
            if [ "\$container" = "\$CLEANUP_CONTAINER" ]; then
              pre_cleanup_cpu=\$cpu_usage
              pre_cleanup_mem=\$mem_usage
              pre_cleanup_mem_perc=\$mem_perc
            fi
          else
            echo "      \$container: Not running"
          fi
        done
        
        # Safe Container Termination
        echo "üõë Gracefully stopping previous environment container: $CLEANUP_CONTAINER"
        echo "   This will free up resources while maintaining rollback capability"
        
        # Edge Case: Check container restart policy
        restart_policy=$(docker inspect --format='{{.HostConfig.RestartPolicy.Name}}' "$CLEANUP_CONTAINER" 2>/dev/null || echo "unknown")
        if [ "$restart_policy" = "always" ] || [ "$restart_policy" = "unless-stopped" ]; then
          echo "‚ö†Ô∏è  WARNING: Container has restart policy '$restart_policy'"
          echo "   Container may restart automatically after cleanup"
          echo "   Consider updating restart policy if permanent shutdown is desired"
        fi
        
        # Edge Case: Check for long-running processes
        echo "üîç Checking for active processes in container..."
        process_count=$(docker exec "$CLEANUP_CONTAINER" sh -c "ps aux | wc -l" 2>/dev/null || echo "0")
        if [ "$process_count" -gt "\$HIGH_PROCESS_COUNT_WARNING" ]; then
          echo "‚ö†Ô∏è  WARNING: Container has $process_count processes running (threshold: \$HIGH_PROCESS_COUNT_WARNING)"
          echo "   Shutdown may take longer than usual"
        fi
        
        # Graceful shutdown with enhanced timeout handling
        echo "‚è±Ô∏è  Initiating graceful shutdown (\${CONTAINER_STOP_TIMEOUT}s timeout)..."
        shutdown_start=$(date +%s)
        
        timeout_buffer=\$((CONTAINER_STOP_TIMEOUT + 5))  # Add 5s buffer for timeout command
        if timeout \$timeout_buffer docker stop --time \$CONTAINER_STOP_TIMEOUT "$CLEANUP_CONTAINER"; then
          shutdown_end=$(date +%s)
          shutdown_duration=\$((shutdown_end - shutdown_start))
          echo "‚úÖ Container $CLEANUP_CONTAINER stopped successfully in \${shutdown_duration}s"
        else
          echo "‚ö†Ô∏è  Graceful stop failed or timed out, attempting force stop..."
          if timeout \$FORCE_KILL_TIMEOUT docker kill "$CLEANUP_CONTAINER"; then
            shutdown_end=$(date +%s)
            shutdown_duration=\$((shutdown_end - shutdown_start))
            echo "‚úÖ Container $CLEANUP_CONTAINER force-stopped"
          else
            echo "‚ùå ERROR: Failed to stop container $CLEANUP_CONTAINER even with force"
            echo "   Container may be in an unresponsive state"
            echo "   Manual intervention may be required: docker kill $CLEANUP_CONTAINER"
            exit 1
          fi
        fi
        
        # Post-cleanup validation
        echo "üîç Post-cleanup validation..."
        sleep \$POST_CLEANUP_WAIT
        
        # Verify container is stopped
        if docker ps --format "{{.Names}}" | grep -q "^$CLEANUP_CONTAINER\\$"; then
          echo "‚ùå ERROR: Container $CLEANUP_CONTAINER is still running after cleanup"
          exit 1
        fi
        
        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        # PROGRESSIVE CONTAINER CLEANUP - ACTUAL REMOVAL
        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        echo ""
        echo "üöÆ Starting progressive container cleanup phase..."
        
        # Skip cleanup if strategy is stop-only
        if [ "\$CLEANUP_STRATEGY" = "stop-only" ]; then
          echo "‚ÑπÔ∏è  Cleanup strategy is 'stop-only' - skipping container removal"
          echo "   Container $CLEANUP_CONTAINER remains available for quick rollback"
        else
          echo "üîç Cleanup strategy: \$CLEANUP_STRATEGY - proceeding with container removal"
          
          # Disk Space Pre-Check
          echo "üíΩ Checking disk space before cleanup..."
          available_disk_gb=$(df -BG . | awk "NR==2{print \$4}" | sed 's/G//' 2>/dev/null || echo "0")
          echo "   Available disk space: \${available_disk_gb}GB (minimum required: \${MIN_DISK_SPACE_GB}GB)"
          
          if [ "\$available_disk_gb" -lt "\$MIN_DISK_SPACE_GB" ]; then
            echo "‚ö†Ô∏è  WARNING: Low disk space (\${available_disk_gb}GB < \${MIN_DISK_SPACE_GB}GB)"
            echo "   Proceeding with cleanup to free space..."
          else
            echo "‚úÖ Sufficient disk space for cleanup operation"
          fi
          
          # Container Image Backup Verification
          if [ "\$VERIFY_IMAGE_BACKUP" = "true" ]; then
            echo "üîç Verifying container image backup availability..."
            container_image=$(docker inspect --format='{{.Config.Image}}' "\$CLEANUP_CONTAINER" 2>/dev/null || echo "unknown")
            
            if [ "\$container_image" != "unknown" ]; then
              if docker images --format "table {{.Repository}}:{{.Tag}}" | grep -q "\$container_image"; then
                echo "‚úÖ Container image backup available: \$container_image"
              else
                echo "‚ö†Ô∏è  WARNING: Container image not found in local registry: \$container_image"
                echo "   Container removal may require rebuilding from scratch"
                
                if [ "\$ENABLE_ROLLBACK_PROTECTION" = "true" ]; then
                  echo "‚ùå ERROR: Rollback protection enabled but image backup unavailable"
                  echo "   Either disable VERIFY_IMAGE_BACKUP or ensure image is available"
                  echo "   Aborting cleanup to prevent rollback issues"
                  cleanup_skipped=true
                fi
              fi
            else
              echo "‚ö†Ô∏è  WARNING: Cannot determine container image for backup verification"
            fi
          fi
          
          # Rollback Protection Test
          if [ "\$ENABLE_ROLLBACK_PROTECTION" = "true" ] && [ "\$cleanup_skipped" != "true" ]; then
            echo "üõ°Ô∏è  Testing rollback capability before cleanup..."
            
            # Test current deployment stability
            rollback_test_passed=0
            for test_attempt in $(seq 1 3); do
              if docker exec "\$CURRENT_CONTAINER" sh -c "curl -sS -f --max-time 3 http://localhost:$(if [ \"\$DEPLOY_TARGET\" = \"blue\" ]; then echo 3001; else echo 3002; fi)/health >/dev/null" 2>/dev/null; then
                rollback_test_passed=\$((rollback_test_passed + 1))
              fi
              sleep 2
            done
            
            if [ \$rollback_test_passed -ge 2 ]; then
              echo "‚úÖ Rollback protection: Current deployment stable (\$rollback_test_passed/3 tests passed)"
            else
              echo "‚ùå ERROR: Rollback protection failed - current deployment unstable"
              echo "   Only \$rollback_test_passed/3 stability tests passed"
              echo "   Aborting cleanup to prevent system instability"
              cleanup_skipped=true
            fi
          fi
          
          # Progressive Container Removal
          if [ "\$cleanup_skipped" != "true" ]; then
            echo ""
            echo "üóëÔ∏è  Executing progressive container cleanup..."
            
            # Pre-removal container information
            echo "üìä Container information before removal:"
            container_size=$(docker ps -a --format "table {{.Names}}\\t{{.Size}}" | grep "\$CLEANUP_CONTAINER" | awk '{print \$2}' || echo "unknown")
            container_created=$(docker inspect --format='{{.Created}}' "\$CLEANUP_CONTAINER" 2>/dev/null | cut -d'T' -f1 || echo "unknown")
            echo "   Container: \$CLEANUP_CONTAINER"
            echo "   Size: \$container_size"
            echo "   Created: \$container_created"
            echo "   Image: \$container_image"
            
            # Apply cleanup delay if configured
            if [ "\$CLEANUP_DELAY_MINUTES" -gt 0 ]; then
              echo "‚è∞ Cleanup delay configured: \$CLEANUP_DELAY_MINUTES minutes"
              echo "   Waiting before container removal..."
              sleep "\$((CLEANUP_DELAY_MINUTES * 60))"
            fi
            
            # Stage 1: Container Removal
            if echo "\$PROGRESSIVE_CLEANUP_STAGES" | grep -q "remove"; then
              echo "üóëÔ∏è  Stage 1: Removing container \$CLEANUP_CONTAINER..."
              removal_start=\$(date +%s)
              
              if docker rm -f "\$CLEANUP_CONTAINER" 2>/dev/null; then
                removal_end=\$(date +%s)
                removal_duration=\$((removal_end - removal_start))
                echo "‚úÖ Container \$CLEANUP_CONTAINER removed successfully in \${removal_duration}s"
                container_removed=true
              else
                echo "‚ùå ERROR: Failed to remove container \$CLEANUP_CONTAINER"
                echo "   Container may be in an unresponsive state or have dependencies"
                echo "   Manual intervention may be required: docker rm -f \$CLEANUP_CONTAINER"
              fi
            else
              echo "‚ÑπÔ∏è  Container removal stage skipped (not in PROGRESSIVE_CLEANUP_STAGES)"
            fi
            
            # Stage 2: Image Cleanup (if full-cleanup strategy)
            if [ "\$CLEANUP_STRATEGY" = "full-cleanup" ]; then
              echo "üóëÔ∏è  Stage 2: Cleaning up unused Docker images..."
              
              # Remove dangling images
              dangling_images=\$(docker images -f "dangling=true" -q | wc -l || echo "0")
              if [ "\$dangling_images" -gt 0 ]; then
                echo "   Found \$dangling_images dangling images to remove"
                if docker image prune -f >/dev/null 2>&1; then
                  echo "‚úÖ Dangling images cleaned up successfully"
                else
                  echo "‚ö†Ô∏è  Warning: Could not clean up dangling images"
                fi
              else
                echo "‚úÖ No dangling images found"
              fi
            fi
            
            # Stage 3: System Cleanup (if full-cleanup strategy)
            if [ "\$CLEANUP_STRATEGY" = "full-cleanup" ]; then
              echo "üóëÔ∏è  Stage 3: System-wide Docker cleanup..."
              
              # Clean up unused containers, networks, and build cache
              echo "   Cleaning up unused Docker objects..."
              cleanup_output=\$(docker system prune -f 2>&1 || echo "cleanup failed")
              
              if echo "\$cleanup_output" | grep -q "Total reclaimed space"; then
                reclaimed_space=\$(echo "\$cleanup_output" | grep "Total reclaimed space" | awk '{print \$(NF-1), \$NF}')
                echo "‚úÖ System cleanup completed - reclaimed: \$reclaimed_space"
              else
                echo "‚ö†Ô∏è  System cleanup completed with unknown results"
              fi
            fi
            
            # Verify removal success
            if [ "\$container_removed" = "true" ]; then
              if docker ps -a --format "{{.Names}}" | grep -q "^\$CLEANUP_CONTAINER\$"; then
                echo "‚ùå ERROR: Container \$CLEANUP_CONTAINER still exists after removal attempt"
                echo "   This indicates a partial cleanup failure"
              else
                echo "‚úÖ Container removal verification successful"
                
                # Update rollback instructions
                echo ""
                echo "üìù Updated Emergency Rollback Instructions:"
                echo "   Previous environment container has been REMOVED"
                echo "   To recreate: cd ~/bgTest/v5ToWindow && docker-compose up -d \${CURRENT_ACTIVE}-app"
                echo "   To switch back: curl -X POST http://api-server:9000/switch/\$CURRENT_ACTIVE"
                echo "   Full recovery: ./scripts/switch-deployment.sh rollback"
              fi
            fi
          else
            echo "‚ö†Ô∏è  Progressive cleanup skipped due to safety checks or configuration"
            echo "   Container \$CLEANUP_CONTAINER remains available for rollback"
          fi
        fi
        
        # Verify current deployment still healthy
        if ! docker exec "$CURRENT_CONTAINER" sh -c "curl -sS -f --max-time 3 http://localhost:$(if [ \"$DEPLOY_TARGET\" = \"blue\" ]; then echo 3001; else echo 3002; fi)/health >/dev/null" 2>/dev/null; then
          echo "‚ùå ERROR: Current deployment health check failed after cleanup"
          echo "üö® URGENT: Consider emergency rollback"
          exit 1
        fi
        
        # Enhanced Post-cleanup Performance Analysis
        echo "üìä Post-cleanup system resource analysis:"
        
        # Post-cleanup system metrics with disk space monitoring
        post_used_memory=$(free -m | awk "/^Mem:/{print \$3}" 2>/dev/null || echo "unknown")
        post_load_avg=$(uptime | awk -F"load average:" '{print \$2}' | sed 's/^[[:space:]]*//' 2>/dev/null || echo "unknown")
        post_free_space=$(df -h . | awk "NR==2{print \$4}" 2>/dev/null || echo "unknown")
        post_disk_used=$(df -h . | awk "NR==2{print \$3}" 2>/dev/null || echo "unknown") 
        post_disk_total=$(df -h . | awk "NR==2{print \$2}" 2>/dev/null || echo "unknown")
        
        echo "   üíª System: Memory \${post_used_memory}/\${total_memory}MB, Load: \$post_load_avg"
        echo "   üíæ Disk Space: Used \$post_disk_used/\$post_disk_total, Available: \$post_free_space"
        
        # Docker-specific disk usage analysis
        echo "   üê≥ Docker storage analysis:"
        docker_system_usage=$(docker system df --format "table {{.Type}}\\t{{.TotalCount}}\\t{{.Size}}\\t{{.Reclaimable}}" 2>/dev/null | tail -n +2 || echo "analysis unavailable")
        if [ "$docker_system_usage" != "analysis unavailable" ]; then
          echo "$docker_system_usage" | while IFS=$'\t' read -r type count size reclaimable; do
            echo "      $type: $count items, $size total, $reclaimable reclaimable"
          done
        else
          echo "      Docker storage analysis unavailable"
        fi
        
        # Calculate comprehensive resource savings
        echo ""
        echo "   üí∞ Resource Savings Analysis:"
        
        # Memory savings calculation
        if [ "\$used_memory" != "unknown" ] && [ "\$post_used_memory" != "unknown" ]; then
          memory_saved=$((used_memory - post_used_memory))
          if [ \$memory_saved -gt 0 ]; then
            echo "      üíæ Memory: \${memory_saved}MB freed (\$used_memory ‚Üí \$post_used_memory MB)"
          elif [ \$memory_saved -lt 0 ]; then
            echo "      üíæ Memory: \$((-memory_saved))MB additional used (\$used_memory ‚Üí \$post_used_memory MB)"
          else
            echo "      üíæ Memory: No significant change (\$used_memory ‚Üí \$post_used_memory MB)"
          fi
        else
          echo "      üíæ Memory: Change calculation unavailable"
        fi
        
        # Disk space savings calculation (compare pre/post cleanup)
        if [ "\$free_space" != "unknown" ] && [ "\$post_free_space" != "unknown" ]; then
          # Extract numeric values for comparison (remove units like GB, MB)
          pre_space_val=$(echo \$free_space | sed 's/[^0-9.]//g' 2>/dev/null || echo "0")
          post_space_val=$(echo \$post_free_space | sed 's/[^0-9.]//g' 2>/dev/null || echo "0")
          pre_space_unit=$(echo \$free_space | sed 's/[0-9.]//g' 2>/dev/null || echo "")
          post_space_unit=$(echo \$post_free_space | sed 's/[0-9.]//g' 2>/dev/null || echo "")
          
          if [ "\$pre_space_unit" = "\$post_space_unit" ] && [ "\$pre_space_val" != "0" ] && [ "\$post_space_val" != "0" ]; then
            # Use awk for floating point comparison
            space_change_status=$(awk -v pre=\$pre_space_val -v post=\$post_space_val 'BEGIN {
              if (post > pre) print "increased"
              else if (post < pre) print "decreased" 
              else print "unchanged"
            }')
            space_change_amount=$(awk -v pre=\$pre_space_val -v post=\$post_space_val 'BEGIN {
              diff = post - pre
              if (diff < 0) diff = -diff
              printf "%.1f", diff
            }')
            
            case \$space_change_status in
              "increased")
                echo "      üíΩ Disk Space: \${space_change_amount}\${post_space_unit} freed (\$free_space ‚Üí \$post_free_space available)"
                ;;
              "decreased")
                echo "      üíΩ Disk Space: \${space_change_amount}\${post_space_unit} additional used (\$free_space ‚Üí \$post_free_space available)"
                ;;
              *)
                echo "      üíΩ Disk Space: No significant change (\$post_free_space available)"
                ;;
            esac
          else
            echo "      üíΩ Disk Space: \$free_space ‚Üí \$post_free_space available"
          fi
        else
          echo "      üíΩ Disk Space: Change calculation unavailable"
        fi
        
        # Cleanup effectiveness validation
        if [ "\$CLEANUP_STRATEGY" != "stop-only" ]; then
          echo "      üóëÔ∏è  Cleanup Level: \$CLEANUP_STRATEGY (container removal enabled)"
          
          # Validate minimum disk space requirement
          post_space_gb=$(echo \$post_free_space | sed 's/G.*//' 2>/dev/null || echo "0")
          if [ "\$post_space_gb" != "unknown" ] && [ "\$post_space_gb" != "0" ]; then
            min_space_check=$(awk -v space=\$post_space_gb -v min=\$MIN_DISK_SPACE_GB 'BEGIN { 
              if (space >= min) print "sufficient"
              else print "insufficient"
            }')
            
            case \$min_space_check in
              "sufficient")
                echo "      ‚úÖ Disk Space Validation: \${post_space_gb}GB available (‚â•\${MIN_DISK_SPACE_GB}GB required)"
                ;;
              "insufficient")
                echo "      ‚ö†Ô∏è  Disk Space Warning: Only \${post_space_gb}GB available (<\${MIN_DISK_SPACE_GB}GB recommended)"
                echo "         Consider running full-cleanup strategy or manual system cleanup"
                ;;
            esac
          fi
        else
          echo "      üóëÔ∏è  Cleanup Level: \$CLEANUP_STRATEGY (containers retained for rollback)"
        fi
        
        # Active container metrics after cleanup
        echo "   üê≥ Active containers after cleanup:"
        for container in $CURRENT_CONTAINER nginx-proxy api-server; do
          if docker ps --format "{{.Names}}" | grep -q "^\$container\$"; then
            cpu_usage=$(docker stats --no-stream --format "{{.CPUPerc}}" \$container 2>/dev/null | sed 's/%//' || echo "N/A")
            mem_usage=$(docker stats --no-stream --format "{{.MemUsage}}" \$container 2>/dev/null || echo "N/A")
            mem_perc=$(docker stats --no-stream --format "{{.MemPerc}}" \$container 2>/dev/null | sed 's/%//' || echo "N/A")
            echo "      \$container: CPU \${cpu_usage}%, Memory \$mem_usage (\${mem_perc}%)"
          else
            echo "      \$container: ‚ùå CRITICAL - Container not running!"
          fi
        done
        
        # Performance metrics summary
        total_cleanup_time=$((shutdown_end - shutdown_start + 5)) # Include validation time
        echo ""
        echo "‚ö° Performance Metrics Summary:"
        echo "   ‚è±Ô∏è  Total cleanup time: \${total_cleanup_time}s"
        echo "   üõë Container shutdown time: \${shutdown_duration}s"
        echo "   üîç Validation and checks: \$((total_cleanup_time - shutdown_duration))s"
        if [ "\$pre_cleanup_mem_perc" != "N/A" ] && [ "\$pre_cleanup_mem_perc" != "" ]; then
          echo "   üìâ Resource reduction: \${pre_cleanup_mem_perc}% memory utilization eliminated"
        fi
        
        echo "üìã Final container status:"
        docker ps --format "table {{.Names}}\\t{{.Status}}\\t{{.Ports}}" | grep -E "(nginx-proxy|api-server|$CURRENT_CONTAINER)"
        
        echo ""
        echo "üéâ CLEANUP COMPLETED SUCCESSFULLY!"
        echo "‚úÖ Previous environment ($CURRENT_ACTIVE) container stopped"
        echo "‚úÖ Current environment ($DEPLOY_TARGET) remains healthy and active"
        echo "‚úÖ Resources freed up for system optimization"
        echo ""
        
        # Integration with existing monitoring system
        echo "üì° Integrating with deployment monitoring system..."
        
        # Notify monitoring system of cleanup event
        if docker ps --format "{{.Names}}" | grep -q "api-server"; then
          cleanup_event="{\\\"event\\\": \\\"container_cleanup\\\", \\\"timestamp\\\": \\\"\$(date -Iseconds)\\\", \\\"stopped_container\\\": \\\"$CLEANUP_CONTAINER\\\", \\\"active_container\\\": \\\"$CURRENT_CONTAINER\\\", \\\"environment\\\": \\\"$CURRENT_ACTIVE\\\", \\\"resource_savings_mb\\\": \\\"$memory_saved\\\", \\\"cleanup_duration_s\\\": \\\"$total_cleanup_time\\\"}"
          
          # Send cleanup notification to API server for monitoring integration
          if curl -X POST -H "Content-Type: application/json" -d "\$cleanup_event" "http://api-server:9000/events/cleanup" --max-time 5 >/dev/null 2>&1; then
            echo "‚úÖ Cleanup event logged to monitoring system"
          else
            echo "‚ö†Ô∏è  Warning: Could not notify monitoring system (API server may not support events endpoint)"
          fi
        else
          echo "‚ö†Ô∏è  Warning: API server not available for monitoring integration"
        fi
        
        # Create monitoring-compatible log entry
        MONITOR_LOG_DIR="/tmp/bluegreen-monitoring"
        mkdir -p "\$MONITOR_LOG_DIR" 2>/dev/null || true
        
        if [ -d "\$MONITOR_LOG_DIR" ]; then
          {
            echo "[\$(date '+%Y-%m-%d %H:%M:%S')] üßπ CLEANUP: Container \$CLEANUP_CONTAINER stopped"
            echo "[\$(date '+%Y-%m-%d %H:%M:%S')] üìä METRICS: Memory saved: \${memory_saved}MB, Duration: \${total_cleanup_time}s"
            echo "[\$(date '+%Y-%m-%d %H:%M:%S')] ‚úÖ STATUS: Active environment \$DEPLOY_TARGET healthy after cleanup"
          } >> "\$MONITOR_LOG_DIR/cleanup-events.log" 2>/dev/null || echo "   Log directory not writable"
          
          echo "‚úÖ Monitoring integration completed"
        else
          echo "‚ö†Ô∏è  Monitoring log directory not available"
        fi
        
        echo ""
        echo "üìù Emergency Rollback Instructions:"
        echo "   To restart previous environment: docker start $CLEANUP_CONTAINER"
        echo "   To switch back: curl -X POST http://api-server:9000/switch/$CURRENT_ACTIVE"
        echo "   Full emergency procedure: ./scripts/switch-deployment.sh rollback"
        echo ""
        # Edge Case: Safe Log File Creation
        CLEANUP_LOG_FILE="cleanup-\$(date +%Y%m%d-%H%M%S 2>/dev/null || echo 'unknown-time').log"
        
        # Edge Case: Ensure log directory is writable
        if ! touch ~/test-write-\$\$ 2>/dev/null; then
          echo "‚ö†Ô∏è  WARNING: Cannot write to home directory for cleanup logs"
          CLEANUP_LOG_FILE="/tmp/\$CLEANUP_LOG_FILE"
          echo "   Using temporary directory: \$CLEANUP_LOG_FILE"
        else
          rm -f ~/test-write-\$\$ 2>/dev/null || true
        fi
        
        # Create comprehensive cleanup log
        {
          echo "# Blue-Green Deployment Cleanup Log"
          echo "CLEANUP_TIMESTAMP=\$(date '+%Y-%m-%d %H:%M:%S %Z' 2>/dev/null || date)"
          echo "CLEANUP_USER=\$(whoami 2>/dev/null || echo 'unknown')"
          echo "CLEANUP_HOST=\$(hostname 2>/dev/null || echo 'unknown')"
          echo "STOPPED_CONTAINER=\$CLEANUP_CONTAINER"
          echo "ACTIVE_CONTAINER=\$CURRENT_CONTAINER"
          echo "PREVIOUS_ENVIRONMENT=\$CURRENT_ACTIVE"
          echo "CURRENT_ENVIRONMENT=\$DEPLOY_TARGET"
          echo "RESTART_POLICY=\$restart_policy"
          echo "SHUTDOWN_DURATION=\${shutdown_duration}s"
          echo "TOTAL_CLEANUP_TIME=\${total_cleanup_time}s"
          echo "PRE_CLEANUP_MEMORY_MB=\$used_memory"
          echo "POST_CLEANUP_MEMORY_MB=\$post_used_memory"
          echo "MEMORY_SAVED_MB=\$memory_saved"
          echo "SYSTEM_MEMORY_TOTAL_MB=\$total_memory"
          echo "AVAILABLE_MEMORY_MB=\$available_memory"
          echo "PROCESS_COUNT=\$process_count"
          echo "PRE_CLEANUP_CPU_USAGE=\${pre_cleanup_cpu}%"
          echo "PRE_CLEANUP_MEM_USAGE=\$pre_cleanup_mem"
          echo "PRE_CLEANUP_MEM_PERCENTAGE=\${pre_cleanup_mem_perc}%"
          echo "LOAD_AVERAGE_BEFORE=\$load_avg"
          echo "LOAD_AVERAGE_AFTER=\$post_load_avg"
          echo ""
          echo "# Emergency Recovery Commands:"
          echo "# docker start \$CLEANUP_CONTAINER"
          echo "# curl -X POST http://api-server:9000/switch/\$CURRENT_ACTIVE"
          echo "# ./scripts/switch-deployment.sh rollback"
        } > ~/$CLEANUP_LOG_FILE 2>/dev/null || {
          echo "‚ö†Ô∏è  WARNING: Failed to create cleanup log file"
          echo "   Log information displayed above for manual recording"
        }
        
        if [ -f ~/$CLEANUP_LOG_FILE ]; then
          echo "üíæ Cleanup record saved to ~/\$CLEANUP_LOG_FILE"
        else
          echo "‚ö†Ô∏è  Cleanup log could not be created - information available in CI logs"
        fi
        
        echo ""
        echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
        echo "üß™ COMPREHENSIVE TESTING & ROLLBACK PROTECTION VALIDATION"
        echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
        
        # Post-Cleanup Comprehensive Testing Suite
        echo "üî¨ Executing comprehensive post-cleanup validation tests..."
        comprehensive_test_start=$(date +%s)
        test_failures=0
        
        # Test 1: End-to-End Request Flow Validation
        echo ""
        echo "Test 1/5: üåê End-to-End Request Flow Validation"
        echo "   Testing complete request flow through NGINX ‚Üí Application ‚Üí Response"
        
        e2e_success=0
        for test_run in $(seq 1 3); do
          if timeout 10 curl -sS -f --max-time 5 "http://nginx-proxy:80/health" >/dev/null 2>&1; then
            if timeout 10 curl -sS -f --max-time 5 "http://nginx-proxy:80/version" >/dev/null 2>&1; then
              e2e_success=$((e2e_success + 1))
              echo "   ‚úÖ E2E Test Run \$test_run: SUCCESS (proxy ‚Üí app ‚Üí response)"
            else
              echo "   ‚ùå E2E Test Run \$test_run: FAILED (version endpoint unavailable)"
            fi
          else
            echo "   ‚ùå E2E Test Run \$test_run: FAILED (health endpoint unavailable)"
          fi
          [ \$test_run -lt 3 ] && sleep 2
        done
        
        if [ \$e2e_success -ge 2 ]; then
          echo "   ‚úÖ End-to-End Flow: PASSED (\$e2e_success/3 tests successful)"
        else
          echo "   ‚ùå End-to-End Flow: FAILED (\$e2e_success/3 tests successful)"
          test_failures=$((test_failures + 1))
        fi
        
        # Test 2: Performance Regression Testing
        echo ""
        echo "Test 2/5: ‚ö° Performance Regression Testing"
        echo "   Measuring response times to detect performance degradation"
        
        response_times=""
        performance_samples=0
        for perf_test in $(seq 1 5); do
          start_time=$(date +%s%3N 2>/dev/null || echo "0")
          if timeout 8 curl -sS -f --max-time 3 "http://nginx-proxy:80/health" >/dev/null 2>&1; then
            end_time=$(date +%s%3N 2>/dev/null || echo "0")
            if [ "\$start_time" != "0" ] && [ "\$end_time" != "0" ]; then
              response_time=$((end_time - start_time))
              response_times="\$response_times \$response_time"
              performance_samples=$((performance_samples + 1))
              echo "   üìä Performance Sample \$perf_test: \${response_time}ms"
            else
              echo "   ‚ö†Ô∏è  Performance Sample \$perf_test: Timing unavailable"
            fi
          else
            echo "   ‚ùå Performance Sample \$perf_test: Request failed"
          fi
          [ \$perf_test -lt 5 ] && sleep 1
        done
        
        if [ \$performance_samples -ge 3 ]; then
          # Calculate average response time using available samples
          total_response_time=0
          for rt in \$response_times; do
            total_response_time=$((total_response_time + rt))
          done
          avg_response_time=$((total_response_time / performance_samples))
          
          echo "   üìä Performance Metrics: \$performance_samples samples, avg \${avg_response_time}ms"
          
          # Performance thresholds (adjustable via environment variables)
          RESPONSE_TIME_WARNING_MS=\${RESPONSE_TIME_WARNING_MS:-1000}
          RESPONSE_TIME_CRITICAL_MS=\${RESPONSE_TIME_CRITICAL_MS:-3000}
          
          if [ \$avg_response_time -le \$RESPONSE_TIME_WARNING_MS ]; then
            echo "   ‚úÖ Performance Regression: PASSED (excellent response times)"
          elif [ \$avg_response_time -le \$RESPONSE_TIME_CRITICAL_MS ]; then
            echo "   ‚ö†Ô∏è  Performance Regression: WARNING (slower than optimal but acceptable)"
          else
            echo "   ‚ùå Performance Regression: FAILED (response times too slow)"
            test_failures=$((test_failures + 1))
          fi
        else
          echo "   ‚ùå Performance Regression: FAILED (insufficient samples collected)"
          test_failures=$((test_failures + 1))
        fi
        
        # Test 3: Rollback Capability Validation
        echo ""
        echo "Test 3/5: üîÑ Rollback Capability Validation"
        echo "   Testing that rollback procedures are functional and available"
        
        rollback_tests_passed=0
        
        # Test 3a: API Server Rollback Endpoint
        if timeout 5 curl -sS -f --max-time 3 "http://api-server:9000/health" >/dev/null 2>&1; then
          echo "   ‚úÖ Rollback Test 3a: API server accessible for rollback operations"
          rollback_tests_passed=$((rollback_tests_passed + 1))
        else
          echo "   ‚ùå Rollback Test 3a: API server unreachable - rollback may be compromised"
        fi
        
        # Test 3b: Container Recreation Capability (if container was removed)
        if [ "\$container_removed" = "true" ]; then
          echo "   üîç Rollback Test 3b: Testing container recreation capability"
          if docker images --format "{{.Repository}}:{{.Tag}}" | grep -q "app-service" 2>/dev/null; then
            echo "   ‚úÖ Rollback Test 3b: Container images available for recreation"
            rollback_tests_passed=$((rollback_tests_passed + 1))
          else
            echo "   ‚ùå Rollback Test 3b: Container images missing - recreation may fail"
          fi
        else
          echo "   ‚úÖ Rollback Test 3b: Previous container available for immediate restart"
          rollback_tests_passed=$((rollback_tests_passed + 1))
        fi
        
        # Test 3c: Network Connectivity for Rollback
        if docker network ls --format "{{.Name}}" | grep -q "bluegreen-network" 2>/dev/null; then
          echo "   ‚úÖ Rollback Test 3c: Blue-Green network available for rollback"
          rollback_tests_passed=$((rollback_tests_passed + 1))
        else
          echo "   ‚ùå Rollback Test 3c: Blue-Green network missing - rollback may fail"
        fi
        
        if [ \$rollback_tests_passed -ge 2 ]; then
          echo "   ‚úÖ Rollback Capability: VERIFIED (\$rollback_tests_passed/3 tests passed)"
        else
          echo "   ‚ùå Rollback Capability: COMPROMISED (\$rollback_tests_passed/3 tests passed)"
          test_failures=$((test_failures + 1))
        fi
        
        # Test 4: System Stability Under Load
        echo ""
        echo "Test 4/5: üèãÔ∏è  System Stability Under Load"
        echo "   Testing system stability with concurrent requests"
        
        stability_start=$(date +%s)
        concurrent_requests=5
        successful_requests=0
        
        echo "   üöÄ Launching \$concurrent_requests concurrent stability tests..."
        
        # Launch concurrent requests in background
        for load_test in $(seq 1 \$concurrent_requests); do
          (
            if timeout 10 curl -sS -f --max-time 5 "http://nginx-proxy:80/health" >/dev/null 2>&1; then
              echo "LOAD_TEST_\${load_test}_SUCCESS" >> /tmp/load_test_results_\$\$ 2>/dev/null || true
            fi
          ) &
        done
        
        # Wait for all background tests to complete
        wait
        
        # Count successful requests
        if [ -f /tmp/load_test_results_\$\$ ]; then
          successful_requests=$(grep -c "SUCCESS" /tmp/load_test_results_\$\$ 2>/dev/null || echo "0")
          rm -f /tmp/load_test_results_\$\$ 2>/dev/null || true
        fi
        
        stability_duration=$(($(date +%s) - stability_start))
        
        echo "   üìä Load Test Results: \$successful_requests/\$concurrent_requests requests succeeded in \${stability_duration}s"
        
        if [ \$successful_requests -ge 4 ]; then
          echo "   ‚úÖ System Stability: PASSED (excellent load handling)"
        elif [ \$successful_requests -ge 3 ]; then
          echo "   ‚ö†Ô∏è  System Stability: WARNING (acceptable but not optimal)"
        else
          echo "   ‚ùå System Stability: FAILED (poor load handling)"
          test_failures=$((test_failures + 1))
        fi
        
        # Test 5: Resource Recovery Validation
        echo ""
        echo "Test 5/5: üìä Resource Recovery Validation"
        echo "   Validating that cleanup actually improved resource utilization"
        
        resource_tests_passed=0
        
        # Validate memory improvement
        if [ "\$memory_saved" != "unknown" ] && [ "\$memory_saved" -ge 0 ]; then
          echo "   ‚úÖ Resource Test 5a: Memory utilization improved (saved: \${memory_saved}MB)"
          resource_tests_passed=$((resource_tests_passed + 1))
        else
          echo "   ‚ö†Ô∏è  Resource Test 5a: Memory utilization unchanged or increased"
        fi
        
        # Validate container count reduction (if container was removed)
        current_containers=$(docker ps --format "{{.Names}}" | wc -l 2>/dev/null || echo "0")
        if [ "\$container_removed" = "true" ]; then
          echo "   ‚úÖ Resource Test 5b: Container count reduced (cleanup successful)"
          resource_tests_passed=$((resource_tests_passed + 1))
        else
          echo "   ‚ÑπÔ∏è  Resource Test 5b: Container retained for rollback (expected behavior)"
          resource_tests_passed=$((resource_tests_passed + 1))
        fi
        
        # Validate disk space (if monitoring available)
        if [ "\$post_free_space" != "unknown" ] && [ "\$free_space" != "unknown" ]; then
          echo "   ‚úÖ Resource Test 5c: Disk space monitoring functional (current: \$post_free_space)"
          resource_tests_passed=$((resource_tests_passed + 1))
        else
          echo "   ‚ö†Ô∏è  Resource Test 5c: Disk space monitoring unavailable"
        fi
        
        if [ \$resource_tests_passed -ge 2 ]; then
          echo "   ‚úÖ Resource Recovery: VALIDATED (\$resource_tests_passed/3 tests passed)"
        else
          echo "   ‚ùå Resource Recovery: FAILED (\$resource_tests_passed/3 tests passed)"
          test_failures=$((test_failures + 1))
        fi
        
        # Comprehensive Testing Summary
        comprehensive_test_duration=$(($(date +%s) - comprehensive_test_start))
        echo ""
        echo "üß™ COMPREHENSIVE TESTING SUMMARY:"
        echo "   ‚è±Ô∏è  Testing Duration: \${comprehensive_test_duration}s"
        echo "   üéØ Tests Executed: 5 comprehensive test suites"
        echo "   ‚ùå Test Failures: \$test_failures"
        
        if [ \$test_failures -eq 0 ]; then
          echo "   ‚úÖ Overall Test Result: ALL TESTS PASSED"
          echo "   üõ°Ô∏è  System Integrity: VERIFIED"
          echo "   üîÑ Rollback Capability: CONFIRMED"
        elif [ \$test_failures -le 1 ]; then
          echo "   ‚ö†Ô∏è  Overall Test Result: MINOR ISSUES DETECTED"
          echo "   üõ°Ô∏è  System Integrity: MOSTLY VERIFIED"
          echo "   üîÑ Rollback Capability: LIKELY FUNCTIONAL"
          echo "   üìù Recommendation: Monitor system closely"
        else
          echo "   ‚ùå Overall Test Result: MULTIPLE FAILURES DETECTED"
          echo "   üö® System Integrity: QUESTIONABLE"
          echo "   üîÑ Rollback Capability: POTENTIALLY COMPROMISED"
          echo "   üöë Recommendation: Consider immediate rollback"
          
          # Optional: Auto-trigger rollback on critical failures
          if [ "\${AUTO_ROLLBACK_ON_FAILURE}" = "true" ] && [ \$test_failures -ge 3 ]; then
            echo ""
            echo "üö® AUTO-ROLLBACK TRIGGERED (critical test failures detected)"
            echo "   Initiating emergency rollback sequence..."
            
            # Trigger emergency rollback via API
            if timeout 10 curl -X POST -f "http://api-server:9000/switch/\$CURRENT_ACTIVE" >/dev/null 2>&1; then
              echo "   ‚úÖ Emergency rollback initiated successfully"
              echo "   ‚ö†Ô∏è  ATTENTION: System has been automatically rolled back"
              echo "   üìã ACTION REQUIRED: Investigate test failures before next deployment"
            else
              echo "   ‚ùå Emergency rollback failed - manual intervention required"
              echo "   üöë URGENT: Manual rollback needed immediately"
            fi
          fi
        fi
        
        echo ""
        echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
        echo "üéØ CLEANUP OPERATION SUMMARY"
        echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
        echo "üìä Operation: Container cleanup completed successfully"
        echo "üê≥ Stopped: \$CLEANUP_CONTAINER (\$CURRENT_ACTIVE environment)"
        echo "‚úÖ Active: \$CURRENT_CONTAINER (\$DEPLOY_TARGET environment)"
        echo "‚è±Ô∏è  Duration: \${total_cleanup_time}s total (\${shutdown_duration}s shutdown)"
        echo "üíæ Savings: \${memory_saved}MB memory freed"
        echo "üìà Health: \$current_health_checks/\$HEALTH_CHECK_ATTEMPTS checks passed"
        echo ""
        echo "üîß CONFIGURATION USED:"
        echo "   Container stop timeout: \${CONTAINER_STOP_TIMEOUT}s"
        echo "   Health check threshold: \$HEALTH_CHECK_SUCCESS_THRESHOLD/\$HEALTH_CHECK_ATTEMPTS"
        echo "   Process count warning: \$HIGH_PROCESS_COUNT_WARNING"
        echo "   Memory warning threshold: \${MIN_MEMORY_WARNING_MB}MB"
        echo ""
        echo "üìã OPERATIONAL STATUS:"
        if [ \$memory_saved -gt 0 ]; then
          echo "   üí∞ Resource optimization: SUCCESSFUL (\${memory_saved}MB freed)"
        else
          echo "   üìä Resource optimization: MINIMAL CHANGE"
        fi
        
        if [ \$shutdown_duration -lt \$CONTAINER_STOP_TIMEOUT ]; then
          echo "   üõë Shutdown performance: EXCELLENT (graceful, \${shutdown_duration}s)"
        else
          echo "   ‚ö†Ô∏è  Shutdown performance: SLOW (may need tuning)"
        fi
        
        echo "   üè• System health: VERIFIED (current deployment stable)"
        echo "   üì° Monitoring: INTEGRATED (events logged)"
        echo ""
        echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
      '

# 10. Emergency Rollback (Manual).
emergency-rollback:
  stage: cleanup-dev
  image: alpine:latest
  <<: [*ssh_setup, *rules_dev_main]
  when: manual
  allow_failure: true
  environment:
    name: production-dev
    url: "http://$DEPLOY_SERVER_DEV"
  script:
    - echo "üö® EMERGENCY ROLLBACK - Immediate traffic restoration"
    - |
      ssh "ubuntu@$DEPLOY_SERVER_DEV" '
        cd ~/bgTest/v5ToWindow
        PREVIOUS_ACTIVE=$(cat ~/current_active.env 2>/dev/null || echo "blue")
        
        echo "üîÑ Emergency rollback to $PREVIOUS_ACTIVE environment..."
        
        # Execute rollback via API - using Docker internal network
        rollback_response=$(docker run --rm --network bluegreen-network curlimages/curl:latest \
          curl -s -X POST "http://api-server:9000/switch/$PREVIOUS_ACTIVE" 2>/dev/null || echo "{\"success\":false}")
        
        if echo "$rollback_response" | jq -e ".success" >/dev/null 2>&1; then
          echo "‚úÖ Emergency rollback successful - traffic restored to $PREVIOUS_ACTIVE"
        else
          echo "‚ùå Emergency rollback failed - manual intervention required"
          exit 1
        fi
        
        # Verify rollback
        if curl -f "http://localhost:80/status" >/dev/null 2>&1; then
          echo "‚úÖ Rollback verification successful"
        else
          echo "‚ùå Rollback verification failed"
        fi
      '