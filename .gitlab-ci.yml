---
# True Blue-Green Deployment CI/CD Pipeline
# Implements zero-downtime deployment with separated container architecture.

stages:
  - build-dev
  - test-dev
  - detect-env-dev
  - deploy-inactive-dev
  - health-check-dev
  - zero-downtime-test-dev
  - switch-traffic-dev
  - verify-deployment-dev
  - cleanup-dev

# Common variables
variables:
  GIT_DEPTH: "0"
  NODE_OPTIONS: "--max_old_space_size=2048"
  DOCKER_DRIVER: overlay2
  COMPOSE_FILE: "docker-compose.yml"
  # Dynamic versioning support
  BLUE_VERSION: "${CI_COMMIT_TAG:-${CI_COMMIT_SHORT_SHA}}"
  GREEN_VERSION: "${CI_COMMIT_TAG:-${CI_COMMIT_SHORT_SHA}}"
  DEPLOYMENT_VERSION: "${CI_COMMIT_TAG:-${CI_COMMIT_SHORT_SHA}}"

# Reusable rules
.rules_dev_and_main: &rules_dev_main
  rules:
    - if: '$CI_COMMIT_BRANCH == "dev"'
    - if: '$CI_COMMIT_BRANCH == "main"'
    - when: never

# Reusable SSH setup
.ssh_setup: &ssh_setup
  before_script:
    - apk add --no-cache bash openssh-client curl jq docker docker-compose
    - eval $(ssh-agent -s)
    - echo "üîç Validating CI/CD Variables..."
    - |
      if [ -z "$AWS_PEM_DEV" ] || [ -z "$DEPLOY_SERVER_DEV" ]; then
        echo "‚ùå ERROR: Required CI/CD variables not configured"
        echo "Required: AWS_PEM_DEV (File), DEPLOY_SERVER_DEV (Variable)"
        exit 1
      fi
    - chmod 600 "$AWS_PEM_DEV"
    - ssh-add "$AWS_PEM_DEV"
    - mkdir -p ~/.ssh
    - echo -e "Host *\n\tStrictHostKeyChecking no\n" > ~/.ssh/config
    - echo "‚úÖ SSH setup completed"

# 1. Build Stage
build-dev:
  stage: build-dev
  image: node:18-alpine
  <<: *rules_dev_main
  script:
    - echo "üèóÔ∏è  Building Blue-Green unified architecture with version ${DEPLOYMENT_VERSION}..."
    - cp "$DEV_ENV_FILE" ./.env || echo "No env file configured"
    - echo "VERSION=${DEPLOYMENT_VERSION}" >> ./.env
    - echo "üì¶ Preparing artifacts for unified container deployment..."
    - echo "üîß Version configuration:"
    - echo "   BLUE_VERSION=${BLUE_VERSION}"
    - echo "   GREEN_VERSION=${GREEN_VERSION}"
    - echo "   DEPLOYMENT_VERSION=${DEPLOYMENT_VERSION}"
    - ls -la app-service/ nginx-service/ api-service/ monitoring/ app-server/ || echo "Service directories ready"
  artifacts:
    expire_in: 3 days
    paths:
      - ./app-service/
      - ./nginx-service/
      - ./api-service/
      - ./monitoring/
      - ./scripts/
      - ./app-server/
      - ./blue-server/
      - ./green-server/
      - ./nginx.conf
      - ./conf.d/
      - ./admin.html
      - ./docker-compose.yml
      - ./.env

# 2. Test Stage
test-dev:
  stage: test-dev
  image: node:18-alpine
  <<: *rules_dev_main
  needs: ["build-dev"]
  script:
    - echo "üß™ Testing unified services architecture..."
    - node -c app-server/app.js
    - node -c blue-server/app.js
    - node -c green-server/app.js
    - node -c api-service/app-updated.js || node -c api-server/app.js
    - echo "‚úÖ All service syntax checks passed - unified + legacy compatibility"

# 3. Environment Detection
detect-active-environment:
  stage: detect-env-dev
  image: alpine:latest
  <<: [*ssh_setup, *rules_dev_main]
  needs: ["build-dev", "test-dev"]
  script:
    - echo "üîç Detecting current active environment..."
    - |
      ssh "ubuntu@$DEPLOY_SERVER_DEV" '
        cd ~/bgTest/v5ToWindow
        echo "üìä Environment Detection:"
        
        # Enhanced environment detection with API fallback
        echo "üîç Detecting current environment with multiple methods..."
        
        if docker ps --filter "name=nginx-proxy" --format "table {{.Names}}" | grep -q nginx-proxy; then
          echo "‚úÖ Blue-Green system is running"
          
          # Try API-based detection first (more reliable)
          API_ACTIVE=$(curl -s --max-time 5 "http://localhost:9000/status" | jq -r ".current_deployment" 2>/dev/null || echo "")
          
          # Fallback to file-based detection
          FILE_ACTIVE=$(docker exec nginx-proxy cat /etc/nginx/conf.d/active.env | grep -o "blue\|green" 2>/dev/null || echo "")
          
          # Choose the most reliable source
          if [ -n "$API_ACTIVE" ] && [ "$API_ACTIVE" != "null" ]; then
            CURRENT_ACTIVE="$API_ACTIVE"
            echo "üìä Using API-detected environment: $CURRENT_ACTIVE"
          elif [ -n "$FILE_ACTIVE" ]; then
            CURRENT_ACTIVE="$FILE_ACTIVE"
            echo "üìÑ Using file-detected environment: $CURRENT_ACTIVE"
          else
            CURRENT_ACTIVE="blue"
            echo "‚ö†Ô∏è  No reliable detection, defaulting to: $CURRENT_ACTIVE"
          fi
          
          # True Blue-Green deployment: Deploy to inactive environment
          if [ "$CURRENT_ACTIVE" = "blue" ]; then
            DEPLOY_TARGET="green"
            echo "üîµ‚Üíüü¢ Current: blue, Deploying to: green"
          else
            DEPLOY_TARGET="blue"
            echo "üü¢‚Üíüîµ Current: green, Deploying to: blue"
          fi
        else
          echo "‚ö†Ô∏è  System not running, defaulting to green deployment"
          CURRENT_ACTIVE="blue"
          DEPLOY_TARGET="green"
        fi
        
        echo "Current active: $CURRENT_ACTIVE"
        echo "Deploy target: $DEPLOY_TARGET"
        
        # Save environment info
        echo "$CURRENT_ACTIVE" > ~/current_active.env
        echo "$DEPLOY_TARGET" > ~/deploy_target.env
      '

# 4. Deploy to Inactive Environment ONLY (ZERO DOWNTIME)
deploy-to-inactive-environment:
  stage: deploy-inactive-dev
  image: alpine:latest
  <<: [*ssh_setup, *rules_dev_main]
  needs: ["detect-active-environment"]
  environment:
    name: inactive-env
    url: "http://$DEPLOY_SERVER_DEV"
  script:
    - echo "üöÄ TRUE BLUE-GREEN DEPLOYMENT - Deploy to inactive environment only"
    - echo "üìÅ Transferring unified service architecture..."
    - ssh "ubuntu@$DEPLOY_SERVER_DEV" "mkdir -p ~/bgTest/v5ToWindow"
    - scp -r ./app-service/ "ubuntu@$DEPLOY_SERVER_DEV:~/bgTest/v5ToWindow/"
    - scp -r ./api-service/ "ubuntu@$DEPLOY_SERVER_DEV:~/bgTest/v5ToWindow/"
    - scp -r ./api-server/ "ubuntu@$DEPLOY_SERVER_DEV:~/bgTest/v5ToWindow/"
    - scp -r ./monitoring/ "ubuntu@$DEPLOY_SERVER_DEV:~/bgTest/v5ToWindow/"
    - scp -r ./app-server/ "ubuntu@$DEPLOY_SERVER_DEV:~/bgTest/v5ToWindow/"
    - scp -r ./blue-server/ "ubuntu@$DEPLOY_SERVER_DEV:~/bgTest/v5ToWindow/"
    - scp -r ./green-server/ "ubuntu@$DEPLOY_SERVER_DEV:~/bgTest/v5ToWindow/"
    - scp -r ./conf.d/ "ubuntu@$DEPLOY_SERVER_DEV:~/bgTest/v5ToWindow/"
    - scp ./docker-compose.yml "ubuntu@$DEPLOY_SERVER_DEV:~/bgTest/v5ToWindow/"
    - scp ./nginx.conf "ubuntu@$DEPLOY_SERVER_DEV:~/bgTest/v5ToWindow/"
    - scp ./admin.html "ubuntu@$DEPLOY_SERVER_DEV:~/bgTest/v5ToWindow/"
    - scp ./.env "ubuntu@$DEPLOY_SERVER_DEV:~/bgTest/v5ToWindow/" || echo "No .env file found, using defaults"
    - echo "üê≥ Deploying ONLY to inactive environment (maintaining zero downtime)..."
    - |
      ssh "ubuntu@$DEPLOY_SERVER_DEV" '
        cd ~/bgTest/v5ToWindow
        
        # True Blue-Green deployment: Deploy to inactive environment
        DEPLOY_TARGET=$(cat ~/deploy_target.env 2>/dev/null || echo "green")
        DEPLOY_VERSION="'${DEPLOYMENT_VERSION}'"
        echo "üéØ Deploying version $DEPLOY_VERSION to $DEPLOY_TARGET environment (True Blue-Green mode)"
        
        # Set version for target environment (True Blue-Green mode)
        if [ "$DEPLOY_TARGET" = "blue" ]; then
          export BLUE_VERSION="$DEPLOY_VERSION"
          echo "BLUE_VERSION=$DEPLOY_VERSION" >> .env
          echo "üîµ True Blue-Green: Setting BLUE_VERSION=$DEPLOY_VERSION"
        else
          export GREEN_VERSION="$DEPLOY_VERSION"
          echo "GREEN_VERSION=$DEPLOY_VERSION" >> .env
          echo "üü¢ True Blue-Green: Setting GREEN_VERSION=$DEPLOY_VERSION"
        fi
        
        # Ensure deployment metadata directory exists
        mkdir -p deployment_state
        
        # Install Docker if needed
        if ! command -v docker &> /dev/null; then
          echo "üì¶ Installing Docker..."
          curl -fsSL https://get.docker.com -o get-docker.sh
          sudo sh get-docker.sh
          sudo usermod -aG docker ubuntu
          sudo systemctl start docker
          sudo systemctl enable docker
        fi
        
        # Ensure Docker permissions and restart if needed
        sudo usermod -aG docker ubuntu
        sudo systemctl restart docker
        sudo chmod 666 /var/run/docker.sock || true
        newgrp docker || true
        
        # Install debugging tools
        sudo apt-get update -qq >/dev/null 2>&1 || true
        sudo apt-get install -y netcat-openbsd net-tools >/dev/null 2>&1 || true
        
        # Install Docker Compose if needed
        if ! command -v docker-compose &> /dev/null; then
          echo "üì¶ Installing Docker Compose..."
          sudo curl -L "https://github.com/docker/compose/releases/download/v2.24.0/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
          sudo chmod +x /usr/local/bin/docker-compose
          sudo ln -sf /usr/local/bin/docker-compose /usr/bin/docker-compose
        fi
        
        # Verify Docker is accessible
        echo "üîç Verifying Docker access..."
        if ! docker ps >/dev/null 2>&1 && ! sudo docker ps >/dev/null 2>&1; then
          echo "‚ùå Docker is not accessible. Please check Docker installation and permissions."
          exit 1
        fi
        
        # Check if system is already running
        if docker ps --filter "name=nginx-proxy" --format "table {{.Names}}" | grep -q nginx-proxy; then
          echo "‚úÖ System is running - deploying to inactive $DEPLOY_TARGET environment"
          
          # TRUE ZERO-DOWNTIME DEPLOYMENT - NO CONTAINER STOP/KILL
          echo "üîÑ Zero-downtime deployment to $DEPLOY_TARGET environment..."
          docker-compose -f docker-compose.yml build ${DEPLOY_TARGET}-app || sudo docker-compose -f docker-compose.yml build ${DEPLOY_TARGET}-app
          docker-compose -f docker-compose.yml up -d --no-deps --force-recreate ${DEPLOY_TARGET}-app || sudo docker-compose -f docker-compose.yml up -d --no-deps --force-recreate ${DEPLOY_TARGET}-app
          
          echo "‚è≥ Waiting for $DEPLOY_TARGET environment to be ready..."
          sleep 30
          
        else
          echo "üèóÔ∏è  Initial system deployment - starting all services"
          docker-compose -f docker-compose.yml down --timeout 10 || sudo docker-compose -f docker-compose.yml down --timeout 10 || true
          docker-compose -f docker-compose.yml build || sudo docker-compose -f docker-compose.yml build
          docker-compose -f docker-compose.yml up -d || sudo docker-compose -f docker-compose.yml up -d
          
          echo "‚è≥ Waiting for all services to be ready (t2.micro needs more time)..."
          sleep 120
          
          # ÏÉÅÏÑ∏ ÎîîÎ≤ÑÍπÖ Ï†ïÎ≥¥ ÏàòÏßë
          echo "üîç [DEBUG] Container status check:"
          docker ps -a --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
          
          echo "üîç [DEBUG] Network information:"
          docker network ls
          docker network inspect bluegreen-network | jq ".[0].Containers" || true
          
          echo "üîç [DEBUG] System resource usage:"
          free -h || true
          df -h || true
        fi
        
        # Verify deployment target is healthy with version validation
        echo "üè• Health checking deployed $DEPLOY_TARGET environment..."
        TARGET_PORT=$(if [ "$DEPLOY_TARGET" = "blue" ]; then echo "3001"; else echo "3002"; fi)
        
        for i in $(seq 1 40); do
          echo "üîç [DEBUG] Health check attempt $i/40 for $DEPLOY_TARGET on port $TARGET_PORT"
          
          # Ìè¨Ìä∏ ÏÉÅÌÉú ÌôïÏù∏
          netstat -tulpn | grep ":$TARGET_PORT " || echo "‚ùå Port $TARGET_PORT not listening"
          
          # Ïª®ÌÖåÏù¥ÎÑà Î°úÍ∑∏ ÌôïÏù∏
          if [ $i -eq 5 ] || [ $i -eq 15 ] || [ $i -eq 30 ]; then
            echo "üîç [DEBUG] Container logs (attempt $i):"
            docker logs ${DEPLOY_TARGET}-app --tail 10 2>&1 || true
            docker logs api-server --tail 10 2>&1 || true
            docker logs nginx-proxy --tail 10 2>&1 || true
          fi
          
          # HTTP ÏùëÎãµ ÏÉÅÏÑ∏ ÌôïÏù∏
          HTTP_RESPONSE=$(curl -s -w "HTTPSTATUS:%{http_code}\n" "http://localhost:$TARGET_PORT/health" 2>&1 || echo "CURL_ERROR")
          echo "üîç [DEBUG] HTTP Response: $HTTP_RESPONSE"
          
          # Îã®Ïàú Ìè¨Ìä∏ Ïó∞Í≤∞ ÌÖåÏä§Ìä∏
          if nc -z localhost $TARGET_PORT 2>/dev/null; then
            echo "‚úÖ Port $TARGET_PORT is open and accepting connections"
          else
            echo "‚ùå Port $TARGET_PORT is not accepting connections"
          fi
          
          # Ïª®ÌÖåÏù¥ÎÑà ÌîÑÎ°úÏÑ∏Ïä§ ÌôïÏù∏
          docker exec ${DEPLOY_TARGET}-app ps aux 2>/dev/null || echo "‚ùå Cannot access ${DEPLOY_TARGET}-app container"
          
          if curl -f "http://localhost:$TARGET_PORT/health" >/dev/null 2>&1; then
            echo "‚úÖ $DEPLOY_TARGET environment is healthy!"
            
            # Validate deployment version
            DEPLOYED_VERSION=$(curl -s "http://localhost:$TARGET_PORT/version" | jq -r ".version" 2>/dev/null || echo "unknown")
            if [ "$DEPLOYED_VERSION" != "unknown" ]; then
              echo "üìã Deployed version: $DEPLOYED_VERSION"
              echo "üÜî Deployment ID: $(curl -s "http://localhost:$TARGET_PORT/version" | jq -r ".deployment_id" 2>/dev/null || echo "unknown")"
            fi
            break
          fi
          
          if [ $i -eq 40 ]; then
            echo "‚ùå $DEPLOY_TARGET environment failed to become healthy"
            echo "üîç [DEBUG] Final diagnostic information:"
            docker ps -a --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
            echo "üìã Container logs:"
            docker logs ${DEPLOY_TARGET}-app --tail 20 2>&1 || echo "No ${DEPLOY_TARGET}-app logs"
            docker logs api-server --tail 20 2>&1 || echo "No api-server logs"
            docker logs nginx-proxy --tail 20 2>&1 || echo "No nginx-proxy logs"
            exit 1
          fi
          
          echo "‚è≥ Waiting for $DEPLOY_TARGET environment... ($i/40)"
          sleep 10
        done
        
        echo "üéâ Inactive environment deployment completed successfully with version tracking!"
      '

# 5. Health Check Inactive Environment
health-check-inactive-environment:
  stage: health-check-dev
  image: alpine:latest
  <<: [*ssh_setup, *rules_dev_main]
  needs: ["deploy-to-inactive-environment"]
  retry: 2
  script:
    - echo "üè• Comprehensive health check of inactive environment..."
    - |
      ssh "ubuntu@$DEPLOY_SERVER_DEV" '
        cd ~/bgTest/v5ToWindow
        DEPLOY_TARGET=$(cat ~/deploy_target.env 2>/dev/null || echo "green")
        echo "üéØ Health checking $DEPLOY_TARGET environment (True Blue-Green mode)..."
        
        # Comprehensive health check
        check_service() {
          local service_name="$1"
          local url="$2"
          local max_attempts=10
          
          echo "üîç Checking $service_name..."
          for i in $(seq 1 $max_attempts); do
            if curl -f --max-time 3 "$url" >/dev/null 2>&1; then
              echo "‚úÖ $service_name is healthy"
              return 0
            fi
            echo "‚è≥ $service_name not ready ($i/$max_attempts)..."
            sleep 3
          done
          echo "‚ùå $service_name health check failed"
          return 1
        }
        
        # Check all services
        overall_status=0
        
        # Check inactive environment through NGINX proxy
        if ! check_service "$DEPLOY_TARGET Server" "http://localhost/$DEPLOY_TARGET/health"; then
          overall_status=1
        fi
        
        # Debug NGINX container before health check
        echo "üîç [DEBUG] NGINX container status:"
        docker ps -a | grep nginx || echo "‚ùå No NGINX container found"
        echo "üîç [DEBUG] NGINX container logs:"
        docker logs nginx-proxy --tail 20 2>&1 || echo "‚ùå Failed to get NGINX logs"
        
        # Check supporting services
        check_service "NGINX Proxy" "http://localhost:80/health" || overall_status=1
        
        # API Server internal check (since port 9000 is not exposed externally)
        echo "üîç Checking API Server internally..."
        docker exec api-server wget --quiet --tries=1 --spider "http://localhost:9000/health" && echo "‚úÖ API Server is healthy" || echo "‚ùå API Server health check failed"
        
        if [ $overall_status -eq 0 ]; then
          echo "üéâ All services are healthy - ready for traffic switch!"
        else
          echo "‚ùå Health check failed - deployment cannot proceed"
          exit 1
        fi
      '

# 6. Zero-Downtime Test (Critical Validation)
zero-downtime-validation:
  stage: zero-downtime-test-dev
  image: alpine:latest
  <<: [*ssh_setup, *rules_dev_main]
  needs: ["health-check-inactive-environment"]
  script:
    - echo "üß™ Running zero-downtime deployment validation..."
    - |
      ssh "ubuntu@$DEPLOY_SERVER_DEV" '
        cd ~/bgTest/v5ToWindow
        echo "üöÄ Starting zero-downtime test before traffic switch..."
        
        # Quick availability test
        echo "üìä Testing current service availability..."
        for i in $(seq 1 30); do
          if ! curl -f --max-time 2 "http://localhost:80/status" >/dev/null 2>&1; then
            echo "‚ùå Service availability test failed"
            exit 1
          fi
          sleep 1
        done
        
        echo "‚úÖ Service is stable and ready for traffic switch"
      '

# 7. Switch Traffic (Manual Approval Required).
switch-traffic-to-inactive:
  stage: switch-traffic-dev
  image: alpine:latest
  <<: [*ssh_setup, *rules_dev_main]
  needs: ["zero-downtime-validation"]
  environment:
    name: production-dev
    url: "http://$DEPLOY_SERVER_DEV"
  when: manual
  allow_failure: false
  script:
    - echo "üîÑ ZERO-DOWNTIME TRAFFIC SWITCH - Manual approval granted"
    - |
      ssh "ubuntu@$DEPLOY_SERVER_DEV" '
        cd ~/bgTest/v5ToWindow
        DEPLOY_TARGET=$(cat ~/deploy_target.env 2>/dev/null || echo "green")
        
        echo "üö¶ Switching traffic to $DEPLOY_TARGET environment (True Blue-Green mode)..."
        
        # Execute traffic switch via API
        switch_response=$(curl -s -X POST "http://localhost:9000/switch/$DEPLOY_TARGET" || echo "{\"success\":false}")
        
        if echo "$switch_response" | jq -e ".success" >/dev/null 2>&1; then
          echo "‚úÖ Traffic successfully switched to $DEPLOY_TARGET"
          echo "üìä Switch details: $switch_response"
        else
          echo "‚ùå Traffic switch failed: $switch_response"
          exit 1
        fi
        
        # Verify switch
        sleep 5
        if curl -f "http://localhost:80/status" >/dev/null 2>&1; then
          echo "‚úÖ Traffic switch verification successful"
        else
          echo "‚ùå Traffic switch verification failed"
          exit 1
        fi
      '

# 8. Deployment Verification
verify-deployment:
  stage: verify-deployment-dev
  image: alpine:latest
  <<: [*ssh_setup, *rules_dev_main]
  needs: ["switch-traffic-to-inactive"]
  script:
    - echo "üîç Verifying zero-downtime deployment completion..."
    - |
      ssh "ubuntu@$DEPLOY_SERVER_DEV" '
        cd ~/bgTest/v5ToWindow
        
        echo "üìä Post-deployment verification..."
        
        # Extended availability test
        failed_checks=0
        total_checks=50
        
        for i in $(seq 1 $total_checks); do
          if ! curl -f --max-time 3 "http://localhost:80/status" >/dev/null 2>&1; then
            failed_checks=$((failed_checks + 1))
          fi
          sleep 1
        done
        
        availability=$(echo "scale=2; (1 - $failed_checks/$total_checks) * 100" | bc -l || echo "100")
        
        echo "üìà Deployment verification results:"
        echo "   - Total checks: $total_checks"
        echo "   - Failed checks: $failed_checks"
        echo "   - Availability: ${availability}%"
        
        if [ "$failed_checks" -eq 0 ]; then
          echo "üéâ ZERO-DOWNTIME DEPLOYMENT SUCCESSFUL!"
          echo "‚úÖ Perfect availability achieved: 100%"
        elif [ "$failed_checks" -le 2 ]; then
          echo "‚ö†Ô∏è  Deployment completed with minor issues"
          echo "   Availability: ${availability}%"
        else
          echo "‚ùå Deployment verification failed"
          echo "   Too many availability issues detected"
          exit 1
        fi
      '

# 9. Cleanup Previous Environment (Manual)
cleanup-previous-environment:
  stage: cleanup-dev
  image: alpine:latest
  <<: [*ssh_setup, *rules_dev_main]
  needs: ["verify-deployment"]
  when: manual
  allow_failure: true
  script:
    - echo "üßπ Cleaning up previous environment..."
    - |
      ssh "ubuntu@$DEPLOY_SERVER_DEV" '
        cd ~/bgTest/v5ToWindow
        CURRENT_ACTIVE=$(cat ~/current_active.env 2>/dev/null || echo "blue")
        
        echo "üóëÔ∏è  Optionally scaling down previous $CURRENT_ACTIVE environment..."
        echo "   (Both environments remain available for instant rollback)"
        echo "   Previous environment: $CURRENT_ACTIVE"
        echo "   Cleanup completed"
      '

# 10. Emergency Rollback (Manual)
emergency-rollback:
  stage: cleanup-dev
  image: alpine:latest
  <<: [*ssh_setup, *rules_dev_main]
  when: manual
  allow_failure: false
  environment:
    name: production-dev
    url: "http://$DEPLOY_SERVER_DEV"
  script:
    - echo "üö® EMERGENCY ROLLBACK - Immediate traffic restoration"
    - |
      ssh "ubuntu@$DEPLOY_SERVER_DEV" '
        cd ~/bgTest/v5ToWindow
        PREVIOUS_ACTIVE=$(cat ~/current_active.env 2>/dev/null || echo "blue")
        
        echo "üîÑ Emergency rollback to $PREVIOUS_ACTIVE environment..."
        
        # Execute rollback via API
        rollback_response=$(curl -s -X POST "http://localhost:9000/switch/$PREVIOUS_ACTIVE" || echo "{\"success\":false}")
        
        if echo "$rollback_response" | jq -e ".success" >/dev/null 2>&1; then
          echo "‚úÖ Emergency rollback successful - traffic restored to $PREVIOUS_ACTIVE"
        else
          echo "‚ùå Emergency rollback failed - manual intervention required"
          exit 1
        fi
        
        # Verify rollback
        if curl -f "http://localhost:80/status" >/dev/null 2>&1; then
          echo "‚úÖ Rollback verification successful"
        else
          echo "‚ùå Rollback verification failed"
        fi
      '